---
title: Dec
author:
  - name: Martin Laptev
    url: https://maptv.github.io
image: /asset/deidek.svg
description: >
  Introducing the Dec measurement system, which uses turns instead of months, weeks, hours, minutes, seconds, and degrees.
draft: true
citation:
  url: https://maptv.github.io/dec
aliases:
  - /d
license: CC BY-SA
lightbox: false
toc: true
toc-depth: 4
bread-crumbs: false
format:
  html:
    grid:
      body-width: 850px
    shift-heading-level-by: 3
    include-after-body:
      - ../asset/cite.html
      - ../asset/style.html
      - ../asset/stamp.html
      - ../asset/tooltip.html
  commonmark: default
filters:
  - ../asset/date.lua
---

```{mermaid}
%%| label: decnav
%%{init: {'theme': 'default', 'themeVariables': { 'fontSize': '32px'}}}%%
flowchart LR
   A[Dec]-->B[date]-->C[time]-->D[snap]-->E[span]
   click A "/dec"
   click B "/dec/date"
   click C "/dec/time"
   click D "/dec/snap"
   click E "/dec/span"
```

This section of my website focuses on Dec, a [measurement system](https://en.wikipedia.org/wiki/System_of_units_of_measurement#:~:text=a%20collection%20of%20units%20of%20measurement%20and%20rules%20relating%20them%20to%20each%20other) that [I](https://maptv.github.io) created. Dec is short for [decimal](https://en.wikipedia.org/wiki/Decimal#:~:text=the%20base%2Dten%20positional%20numeral%20system). All Dec measurements are based on [turns](https://en.wikipedia.org/wiki/Turn_%28angle%29#:~:text=a%20unit%20of%20plane%20angle%20measurement%20equal%20to%202%CF%80%C2%A0radians%2C%20360%C2%A0degrees). A turn ([$\tau$](https://en.wikipedia.org/wiki/Turn_%28angle%29#:~:text=the%20Greek%20letter,to%20one%20turn)) represents a circle‚≠ïÔ∏èand is equal to 2$\pi$ radians or 360 degrees. Any kind of angleüìê, such as a [bearing](https://en.wikipedia.org/wiki/Bearing_(navigation)#:~:text=the%20horizontal%20angle%20between%20the%20direction%20of%20an%20object%20and%20north%20or%20another%20object) on a [compass](https://en.wikipedia.org/wiki/Compass#:~:text=a%20device%20that%20shows%20the%20cardinal%20directions%20used%20for%20navigation%20and%20geographic%20orientation)üß≠or a [\${rainbowHue0}](https://en.wikipedia.org/wiki/Hue#:~:text=an%20angular%20position%20around%20a%20central%20or%20neutral%20point%20or%20axis%20on%20a%20color%20space%20coordinate%20diagram%20(such%20as%20a%20chromaticity%20diagram)%20or%20color%20wheel) on a [colorüé®wheel](https://en.wikipedia.org/wiki/Color_wheel#:~:text=an%20abstract%20illustrative%20organization%20of%20color%20hues%20around%20a%20circle), can be measured in turns or [submultiples](https://en.wikipedia.org/wiki/Multiple_(mathematics)#:~:text=the%20quotient%20of%20the%20main%20unit%20by%20an%20integer) of turns like [milliturns]{.under .tool data-bs-toggle="tooltip" data-bs-title="thousandths of a turn"} ([$m\tau$](https://en.wikipedia.org/wiki/Turn_%28angle%29#:~:text=e.g.%2C%20centiturns%20(ctr)%2C-,milliturns,-(mtr)%2C%20etc)): \${rainbowMtr0}.

The rotation of the colorüé®wheel compassüß≠below‚¨áÔ∏èis determined by the sliderüéöÔ∏èon the top barüìäof the [Observable](https://observablehq.com) [HSL](https://en.wikipedia.org/wiki/HSL_and_HSV#:~:text=hue%2C%20saturation%2C%20and%20lightness) [colorüé®picker](https://en.wikipedia.org/wiki/Color_picker#:~:text=a%20graphical%20user%20interface%20widget%2C%20usually%20found%20within%20graphics%20software%20or%20online%2C%20used%20to%20select%20colors) beneath it. HSL triplets, (\${rainbowDeg}${slStr}, specify \${rainbowHue1} in degrees with their first value. Degrees can succinctly identify the hues of pure [additive](https://en.wikipedia.org/wiki/Primary_color#:~:text=summing%20the%20spectral%20power%20distributions%20(the%20intensity%20of%20each%20wavelength)%20of%20the%20individual%20light%20sources) ([red]{.red}=0¬∞, [green]{.lime}=120¬∞, [blue]{.azul}=240¬∞) and [subtractive](https://en.wikipedia.org/wiki/Primary_color#:~:text=predicts%20the%20resultant%20spectral%20power%20distribution%20of%20light%20filtered%20through%20overlaid%20partially%20absorbing%20materials) ([yellow]{.yellow}=60¬∞, [cyan]{.cyan}=180¬∞, [magenta]{.magenta}=300¬∞) [primary colors](https://en.wikipedia.org/wiki/Primary_color#:~:text=colorants%20or%20colored%20lights%20that%20can%20be%20mixed%20in%20varying%20amounts%20to%20produce%20a%20gamut%20of%20colors).

To specify the hues of these colors in turns, we would need to use fractions or repeating decimal numbers ([red]{.red}=0, [green]{.lime}=1/3=.[3]{style="text-decoration-line:overline;"}, [blue]{.azul}=2/3=.[6]{style="text-decoration-line:overline;"}, [yellow]{.yellow}=1/6=.1[6]{style="text-decoration-line:overline;"}, [cyan]{.cyan}=1/2=0.5, [magenta]{.magenta}=5/6=.8[3]{style="text-decoration-line:overline;"}). With only three characters, [hex triplets](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet:~:text=hexadecimal%20number%20used%20in%20HTML%2C%20CSS%2C%20SVG%2C%20and%20other%20computing%20applications%20to%20represent%20colors), \${rainbowHex}, can stipulate any pure primary color ([red]{.red}=f00, [green]{.lime}=0f0, [blue]{.azul}=00f, [yellow]{.yellow}=ff0, [cyan]{.cyan}=0ff, [magenta]{.magenta}=f0f), not just its \${rainbowHue2}.

```{ojs}
//| echo: false
//| label: colorwheelcompass
// https://observablehq.com/@pjedwards/compass-rose-as-legend-with-colors
svg`<svg width="${size}" height="${size}" viewBox="${-size/2} ${-size/2} ${size} ${size}">
  <g transform='rotate(${Math.round(-chosenHsl.h)})'>
  ${repeat(tick(radius, 5, '#434343'), numMinorTicks * 4 * numMajorTicks)}
  ${repeat(tick(radius, 8), numMajorTicks * 4)}
  ${repeat(`<path d="M 0,-${radius+12} l 3,10 l -6,0 z" fill="black" stroke="black" stroke-width="1"/>`, 4, 0)}
  ${repeat(`<path d="M 0,-${radius+12} l 3,10 l -6,0 z" fill="white" stroke="black" stroke-width="1"/>`, 4, 45)}
  <circle r="${radius}" fill="#d3d3d3" stroke="#434343" stroke-width="3" />
  ${repeat(directionMarker(radius+14, 24), 4, 0)}
  ${repeat(directionMarker(radius+12, 24), 4, 45)}
  ${repeat(turnMarker(radius+14, 32), 4, 0)}
  ${repeat(turnMarker(radius+12, 32), 4, 45)}
  ${repeat(pie(radius-margin/2, 2 * Math.PI * (radius-margin/2) / piecolors.length / 2, 1, piecolors), piecolors.length, 360/piecolors.length)}
</svg>
`
```

```{ojs}
//| echo: false
//| label: colorpicker
// https://observablehq.com/@d3/hcl-color-picker
viewof chosenHsl = picker("hsl", [
  { name: "h", domain: [0, 360] },
  { name: "s", domain: [0, 1] },
  { name: "l", domain: [0, 1] }
], d3.hsl(180, 1, .5))
```

```{ojs}
//| echo: false
//| label: directionconverter
function turn2comp(turn) {
  return ["N", "NE", "E", "SE", "S", "SW", "W", "NW"][Math.round(turn / 125) % 8]
}
```


In contrast to primary colorüé®hues, [compassüß≠directions](https://en.wikipedia.org/wiki/Cardinal_direction) are essentially [dyadic rationals](https://en.wikipedia.org/wiki/Dyadic_rational#:~:text=a%20number%20that%20can%20be%20expressed%20as%20a%20fraction%20whose%20denominator%20is%20a%20power%20of%20two) and thus work well with turns. Milliturns can represent the [cardinal](https://en.wikipedia.org/wiki/Cardinal_direction#:~:text=north%2C%20south%2C%20east%2C%20and%20west) (N=0, E=250, S=500, W=750) and [intercardinal](https://en.wikipedia.org/wiki/Cardinal_direction#:~:text=northeast%20(NE)%2C%20southeast%20(SE)%2C%20southwest%20(SW)%2C%20and%20northwest%20(NW)) (NE=125, SE=375, SW=625, NW=875) directions as integers with three digits or fewer. The milliturn value selected above‚¨ÜÔ∏è, \${rainbowMtr1}, is closest to the \${rainbowDir} compassüß≠direction.

In the colorüé®wheel and compassüß≠examples above, each type of turn is used individually. Different types of turns can also work together in groups. [Geopositioning](https://en.wikipedia.org/wiki/Geopositioning#:~:text=the%20process%20of%20determining%20or%20estimating%20the%20geographic%20position%20of%20an%20object%20or%20a%20person)üìçrelies on a pair of coordinates: longitude ($\lambda$) and latitude ($\phi$). When the globeüåçbelow‚¨áÔ∏èdetects a clicküñ±Ô∏èevent, it marks the chosen location and provides relevant information like the $\lambda$ and $\phi$ angles in milliturns.

 along with information about the chosen location
or use longitude and latitude along with a compassüß≠bearing ($\gamma$) to control the globeüåçbelow in three dimensions.

The colorwheel compassdemonstrates that are, which can be truncated to three digits. an alternative to degrees that instead of degrees advantage of degrees is their incredible divisibility.

Colors can be represented by HSL, , []{.mono}, or [RGB](https://en.wikipedia.org/wiki/RGB_color_model#:~:text=an%20additive%20color%20model%5B1%5D%20in%20which%20the%20red%2C%20green%2C%20and%20blue%20primary%20colors%20of%20light%20are%20added%20together%20in%20various%20ways%20to%20reproduce%20a%20broad%20array%20of%20colors), [\${rainbowD3.formatRgb().slice(3)}]{.mono}, triplets. Hex triplets are [base16](https://en.wikipedia.org/wiki/Hexadecimal#:~:text=a%20positional%20numeral%20system%20that%20represents%20numbers%20using%20a%20radix%20(base)%20of%20sixteen), RGB triplets are [base256](https://en.wikipedia.org/wiki/List_of_numeral_systems#:~:text=two%20pentadecimal%20digits.-,256,-Number%20expressible%20with), and 

Turns can represent anything that is circular, spherical, or cyclical, like the , a [compass](https://en.wikipedia.org/wiki/Compass#:~:text=a%20device%20that%20shows%20the%20cardinal%20directions%20used%20for%20navigation%20and%20geographic%20orientation), [Earth's orbits](https://en.wikipedia.org/wiki/Earth%27s_orbit#:~:text=complete%20orbit%20takes-,365.256%C2%A0days,-(1%20sidereal%20year)) around the Sun (years), [Earth's rotations](https://en.wikipedia.org/wiki/Earth%27s_rotation#:~:text=the%20rotation%20of%20planet%20Earth%20around%20its%20own%20axis) on [its axis](https://en.wikipedia.org/wiki/Axial_tilt#:~:text=the%20imaginary%20line%20that%20passes%20through%20both%20the%20north%20pole%20and%20south%20pole) (days), [meridians](https://en.wikipedia.org/wiki/Meridian_%28geography%29#:~:text=words%2C%20it%20is-,a%20line%20of%20longitude,-.%20The%20position%20of), and [parallels](https://en.wikipedia.org/wiki/Circle_of_latitude#:~:text=an%20abstract%20east%E2%80%93west%20small%20circle%20connecting%20all%20locations%20around%20Earth%20(ignoring%20elevation)%20at%20a%20given%20latitude%20coordinate%20line).
A [quarter meridian](https://en.wikipedia.org/wiki/Meridian_arc#Quarter_meridian:~:text=The%20distance%20from%20the%20equator%20to%20the%20pole) is very close to 10 [megameters]{.under .tool data-bs-toggle="tooltip" data-bs-title="millions of meters"} because the length of a [meter](https://en.wikipedia.org/wiki/Metre#Definition:~:text=the%20base%20unit%20of%20length%20in%20the%20International%20System%20of%20Units) was [once defined](https://en.wikipedia.org/wiki/Metre#:~:text=one%20ten%2Dmillionth%20of%20the%20distance%20from%20the%20equator%20to%20the%20North%20Pole) as a ten millionth of the distance from the [Equator](https://en.wikipedia.org/wiki/Equator#:~:text=the%20circle%20of%20latitude%20that%20divides%20Earth%20into%20the%20Northern%20and%20Southern%20hemispheres) to the [North Pole](https://en.wikipedia.org/wiki/North_Pole#:~:text=the%20point%20in%20the%20Northern%20Hemisphere%20where%20the%20Earth%27s%20axis%20of%20rotation%20meets%20its%20surface).

![](../asset/quartermeridian.svg)

For time measurement, Dec uses turns to measure years, days, longitudes, and latitudes. can therefore represent 

The symbol $\tau$ represents any kind of turn. A turn can be a year, a day, a meridian, a parallel, or a colorüé®wheel.

are many kinds of turns. can  Dec uses names to distinguish between different kinds of turns. of years, and called days and 

In geopositioning, a turn can be a circle of longitude or latitude.


are 's turns [turns](https://en.wikipedia.org/wiki/Earth%27s_rotation#:~:text=the%20rotation%20of%20planet%20Earth%20around%20its%20own%20axis) on . days are turns.
 In time measurement, both years and days are turns.

various Dec measures [longitude](https://en.wikipedia.org/wiki/Longitude#:~:text=a%20geographic%20coordinate%20that%20specifies%20the%20east%2Dwest%20position%20of%20a%20point%20on%20the%20surface%20of%20the%20Earth%2C%20or%20another%20celestial%20body) and the [time-of-day]{.cyan} ([tod]{.cyan .under .tool data-bs-toggle="tooltip" data-bs-title="time-of-day"}) in terms of [Earth](https://en.wikipedia.org/wiki/Earth#:~:text=the%20third%20planet%20from%20the%20Sun)'s [turns](https://en.wikipedia.org/wiki/Earth%27s_rotation#:~:text=the%20rotation%20of%20planet%20Earth%20around%20its%20own%20axis) on [its axis](https://en.wikipedia.org/wiki/Axial_tilt#:~:text=the%20imaginary%20line%20that%20passes%20through%20both%20the%20north%20pole%20and%20south%20pole).
In different contexts of time, a turn is day. A turn of longitude is called a circle.

The current [tod]{.cyan .under .tool data-bs-toggle="tooltip" data-bs-title="time-of-day"} is an approximation the longitude of the Sun.

 Turns help us understand the relationship between longitude and tod.
A half turn separates noon and midnight or the Western and Eastern Hemispheres.

Longitude defines the ten Dec time zones that standardize the [tod]{.cyan .under .tool data-bs-toggle="tooltip" data-bs-title="time-of-day"}.

Longitudes start at [Meridian 0](https://en.wikipedia.org/wiki/18th_meridian_west#:~:text=a%20line%20of%20longitude%20that%20extends%20from%20the%20North%20Pole%20across%20the%20Arctic%20Ocean%2C%20Greenland%2C%20Iceland%2C%20the%20Atlantic%20Ocean%2C%20the%20Canary%20Islands%2C%20the%20Southern%20Ocean%2C%20and%20Antarctica%20to%20the%20South%20Pole) and [tods]{.cyan .under .tool data-bs-toggle="tooltip" data-bs-title="times-of-day"} start at [Dot 0]{.cyan .under .tool data-bs-toggle="tooltip" data-bs-title="midnight"}.

Meridian 0 is the Dec [International Date Line](https://en.wikipedia.org/wiki/International_Date_Line#:~:text=the%20line%20between%20the%20South%20and%20North%20Poles%20that%20is%20the%20boundary%20between%20one%20calendar%20day%20and%20the%20next) and [prime meridian](https://en.wikipedia.org/wiki/Prime_meridian#:~:text=an%20arbitrarily%2Dchosen%20meridian%20%28a%20line%20of%20longitude%29%20in%20a%20geographic%20coordinate%20system%20at%20which%20longitude%20is%20defined%20to%20be%200%C2%B0), whereas .

41.[6]{.over} 

[Meridian 1](https://en.wikipedia.org/wiki/18th_meridian_east#:~:text=a%20line%20of%20longitude%20that%20extends%20from%20the%20North%20Pole%20across%20the%20Arctic%20Ocean%2C%20Europe%2C%20Africa%2C%20the%20Atlantic%20Ocean%2C%20the%20Southern%20Ocean%2C%20and%20Antarctica%20to%20the%20South%20Pole) divides Europe and Africa into Western and Eastern halves.

 which runs through Iceland and the Atlantic Ocean just West of Africa,
In the context of time measurement, a turn on Earth's axis is called a day and a turn around the Sun is a year.

 for [geopositioning](https://en.wikipedia.org/wiki/Geopositioning#:~:text=the%20process%20of%20determining%20or%20estimating%20the%20geographic%20position%20of%20an%20object%20or%20a%20person)

To measure time, Dec uses years and days. Years are turns of a celestial body around [the point it orbits](https://en.wikipedia.org/wiki/Barycenter_%28astronomy%29#:~:text=the%20point%20about%20which%20the%20bodies%20orbit). Days are turns of a [celestial body](https://en.wikipedia.org/wiki/Astronomical_object#:~:text=a%20single%2C%20tightly%20bound%2C%20contiguous%20entity) on [its axis](https://en.wikipedia.org/wiki/Axial_tilt#:~:text=the%20imaginary%20line%20that%20passes%20through%20both%20the%20north%20pole%20and%20south%20pole).

The distinguishing characteristics of Dec are its simplicity and consistency. These qualities are evident when comparing Dec and [UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time#:~:text=the%20primary%20time%20standard%20globally%20used%20to%20regulate%20clocks%20and%20time) time zones using the [toggle](https://observablehq.com/@observablehq/input-toggle)‚úÖinputs beneath the worldüåèmapüó∫Ô∏èbelow‚¨áÔ∏è. The 10 Dec time zones are all 1 [deciturn]{.under .tool data-bs-toggle="tooltip" data-bs-title="a tenth of a turn"} wide, whereas the 40 UTC time zones shown on the map all deviate from their standard width of 41‚Öî [milliturns]{.under .tool data-bs-toggle="tooltip" data-bs-title="thousandths of a turn"} to conform to political boundaries.

```{ojs}
//| echo: false
//| label: zonemap
viewof coordinates = worldMapCoordinates([162, 0, projection], [width, height])
```

```{ojs}
//| echo: false
//| label: toggles
// https://observablehq.com/@d3/solar-terminator
// https://observablehq.com/@mbostock/time-zones
viewof dectoggle = Inputs.toggle({label: "Dec", value: true})
viewof border = Inputs.toggle({label: "Borders", value: false})
viewof suntoggle = Inputs.toggle({label: "Shade", value: true})
viewof utctoggle = Inputs.toggle({label: "UTC", value: false})
```

```{ojs}
//| echo: false
//| label: projselect
viewof select = Inputs.select(
  projections, {label: "Projection:", format: x => x.name, value: projections.find(t => t.name === "Equirectangular (plate carr√©e)")})
```

In addition to showing and hiding time zones, the toggle‚úÖinputs also can add country borders and a [solar‚òÄÔ∏èterminator](https://en.wikipedia.org/wiki/Terminator_(solar)#:~:text=a%20moving%20line%20that%20divides%20the%20daylit%20side%20and%20the%20dark%20night%20side%20of%20a%20planetary%20body) shade effect to the mapüó∫Ô∏è. For a different perspective on the worldüåè, you can change the [mapüó∫Ô∏èprojection](https://observablehq.com/plot/features/projections) using the [select‚ÜïÔ∏èinput](https://observablehq.com/documentation/inputs/overview#select) beneath the toggle‚úÖinputs. All mapüó∫Ô∏èprojections perform some kind of transformation to show a sphere on a flat surface.

For a more realistic view of the world, you can interact with the globeüåêbelow‚¨áÔ∏è. as it really is 

Dec has ten [time‚è≥zones](https://en.wikipedia.org/wiki/Time_zone#:~:text=an%20area%20which%20observes%20a%20uniform%20standard%20time) which are each one [deciturn]{.under .tool data-bs-toggle="tooltip" data-bs-title="a tenth of a turn"} wide and are numbered zero through nine, like the ten [meridians](https://en.wikipedia.org/wiki/Meridian_%28geography%29#:~:text=words%2C%20it%20is-,a%20line%20of%20longitude,-.%20The%20position%20of) that separate them. Zone [0]{.lime} is in between Meridians 0 and 1. [Meridian 0](https://en.wikipedia.org/wiki/18th_meridian_west#:~:text=a%20line%20of%20longitude%20that%20extends%20from%20the%20North%20Pole%20across%20the%20Arctic%20Ocean%2C%20Greenland%2C%20Iceland%2C%20the%20Atlantic%20Ocean%2C%20the%20Canary%20Islands%2C%20the%20Southern%20Ocean%2C%20and%20Antarctica%20to%20the%20South%20Pole), which runs through Iceland and the Atlantic Ocean just West of Africa, is the Dec [International Date Line](https://en.wikipedia.org/wiki/International_Date_Line#:~:text=the%20line%20between%20the%20South%20and%20North%20Poles%20that%20is%20the%20boundary%20between%20one%20calendar%20day%20and%20the%20next) and [prime meridian](https://en.wikipedia.org/wiki/Prime_meridian#:~:text=an%20arbitrarily%2Dchosen%20meridian%20%28a%20line%20of%20longitude%29%20in%20a%20geographic%20coordinate%20system%20at%20which%20longitude%20is%20defined%20to%20be%200%C2%B0). [Meridian 1](https://en.wikipedia.org/wiki/18th_meridian_east#:~:text=a%20line%20of%20longitude%20that%20extends%20from%20the%20North%20Pole%20across%20the%20Arctic%20Ocean%2C%20Europe%2C%20Africa%2C%20the%20Atlantic%20Ocean%2C%20the%20Southern%20Ocean%2C%20and%20Antarctica%20to%20the%20South%20Pole) divides Europe and Africa into Western and Eastern halves.

The [choropleth](https://en.wikipedia.org/wiki/Choropleth_map#:~:text=a%20type%20of%20statistical%20thematic%20map%20that%20uses%20pseudocolor%2C%20meaning%20color%20corresponding%20with%20an%20aggregate%20summary%20of%20a%20geographic%20characteristic%20within%20spatial%20enumeration%20units%2C%20such%20as%20population%20density%20or%20per%2Dcapita%20income)üé®mapüó∫Ô∏èbelow shows all ten Dec meridians and the full spectrum of UTC time‚è≥zones. The UTC time‚è≥zones to the East of New Zealand have negative UTC offsets and filled in with reddish colors. By design, all Dec time‚è≥zones have positive offsets. Therefore, Zones 6 to 9 are roughly 1 day ahead of their UTC analogs unless we subtract 10 to make their offsets negative.


The time in any Dec time‚è≥zone differs from the closest UTC time‚è≥differ by -5 to 5 [centiturns]{.under .tool data-bs-toggle="tooltip" data-bs-title="hundredths of a turn"}. When comparing the time in a Dec and UTC time‚è≥zones, there is no difference between Zone 0 and UTC+00:00 or Zone 5 and UTC+12:00. [Deciturns]{.under .tool data-bs-toggle="tooltip" data-bs-title="tenths of a turn"} and hours do not line up perfectly. 

UTC+00:00 is in the middle of Zone 0, but makes detours to include Iceland and other islands. Except for such detours, each UTC time zone is 41.6ÃÖ milliturns wide.

The ISOüåê8601 format is 

If the Dec day-of-year ([doy]{.under .tool data-bs-toggle="tooltip" data-bs-title="day-of-year"}), [\${String(decDate).padStart(3, "0")}]{.cyan}.[\${decTime.toFixed(5).slice(2)}]{.cyan}, is greater than [306]{.under .tool data-bs-toggle="tooltip" data-bs-title="January 1"}, the Dec year is 1 less than the ISOüåêyear.

The ISOüåê8601 [time‚è≥interval](https://en.wikipedia.org/wiki/ISO_8601#Time_intervals:~:text=the%20intervening%20time%20between%20two%20time%20points) from now until midnight can be expressed without including the current time as , which is equivalent to the Dec spanüåà.

ISOüåê8601 and Dec are  different objectives. ISOüåê8601 seeks to standardize how we measure time, whereas Dec aims to completely redefine how we measure time.


Unlike ISOüåê8601, the documentation describing Dec is available for free under a [Creative Commons license](https://en.wikipedia.org/wiki/Creative_Commons_license#:~:text=one%20of%20several%20public%20copyright%20licenses%20that%20enable%20the%20free%20distribution%20of%20an%20otherwise%20copyrighted%20%22work%22). While ISOüåê8601 standardizes,

 can be split two components: the Dec calendarüóìÔ∏è(Decalendar) and clocküïì(Declock).
The year in Dec is the same as in the 
Dec countsüßÆyears and days as integers and fractions. In Dec, the [integer](https://en.wikipedia.org/wiki/Decimal#:~:text=the%20integer%20written%20to%20the%20left%20of%20the%20decimal%20separator) and [fractional](https://en.wikipedia.org/wiki/Fractional_part#:~:text=the%20excess%20beyond%20that%20number%27s%20integer%20part) part of a year form a date, while the fractional part of a year. The fractional years are expressed by  while [fractional days](https://en.wikipedia.org/wiki/Decimal_time#Fractional_days) are . since the Dec [epoch](https://en.wikipedia.org/wiki/Epoch#:~:text=an%20instant%20in%20time%20chosen%20as%20the%20origin%20of%20a%20particular%20calendar%20era), Dec tracks the date as and the time of day as fractional days using a single number called the [doy]{.under .tool data-bs-toggle="tooltip" data-bs-title="day-of-year"}.
In essence, Decalendar and Declock  countüßÆfractions of a year and a day, respectively. The numerator and denominator for Decalendar is the number of days in the year, and the Declock denominator is $10^x$, where $x$ is the number of digits in the numerator. In both systems, only the numerator, not the denominator, is provided. In the context of Decalendar, the numerator is the days that have passed in the year, while in the context of Declock, the numerator is the parts of the day that have passed in the day.

To avoid any confusion between the two, we can say [Day 5]{.underline .tool data-bs-toggle="tooltip" data-bs-title="March 6"} to mean the date when 5 days have passed this year or [Day 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="March 1"} to mean the first day-of-year ([doy]{.under .tool data-bs-toggle="tooltip" data-bs-title="day-of-year"}). This is like the use of the term "day zero" in other contexts, such as epidemiology. The analogous term for times is "Dot". The word "Dot" conveys that at its core Declock is a system built on [fractional days](https://en.wikipedia.org/wiki/Decimal_time#Fractional_days) expressed as decimal numbers. The 5 in "Dot 5" can be thought of as a number after a decimal (0.5) or a numerator (‚Åµ/‚ÇÅ‚ÇÄ), either way it means noon, the time when half the day has passed.

The analogy to decimals or fractions is important, because it explains why adding a zero at the end of a time does not change the time, only the implied tolerance of time points or the implied duration of time intervals. If Dot 5 is a time point, it has an implied tolerance of 5% of the day ($.5¬±.05$), because any time after Dot 45 and before Dot 55 ($[.45, .55)$) would round to Dot 5. On the other hand, if Dot 5 is the start time for a time interval, that interval is implied to start at Dot 5 and end before Dot 6 ($[.5, .6)$) and thus have a duration of 10% of the day (Dot 6-Dot 5). Every additional digit we add decreases the implied tolerance and the implied duration 10-fold.

If we really want to insist on punctuality, we could include up to 5 digits in a time. Specifying times with more than 5 digits is possible, and may be useful for scientific or technical purposes, but it is analogous to providing [extremely long GPS coordinates](https://xkcd.com/2170/); at some point the level of precision stops having relevance to daily life. If we want to strive for the highest level of precision possible, we can add the word "sharp" or the `#` symbol to the time. Saying "5 Sharp" or writing `5#` means as close as possible to noon. Times that include `#` cannot have an implied duration. We can only add `#` to a time, so there is no need say "Dot 5 Sharp" or write `.5#`.


```{mermaid}
%%| label: decnav
%%{init: {'theme': 'default', 'themeVariables': { 'fontSize': '32px'}}}%%
flowchart LR
   A[Dec]-->B[date]-->C[time]-->D[snap]-->E[span]
   click A "/dec"
   click B "/dec/date"
   click C "/dec/time"
   click D "/dec/snap"
   click E "/dec/span"
```

```{ojs}
//| echo: false
//| output: false
// https://observablehq.com/@observablehq/text-color-annotations-in-markdown
function textcolor(content, style = {}) {
  function yiq(color) {
    const {r, g, b} = d3.rgb(color);
    return (r * 299 + g * 587 + b * 114) / 1000 / 255; // returns values between 0 and 1
  }
  const {
    background,
    color = yiq(background) >= 0.5 ? "#000" : "white",
    padding = "0 5px",
    borderRadius = "4px",
    fontWeight = 400,
    fontFamily = "monospace",
    ...rest
  } = typeof style === "string" ? {background: style} : style;
  return htl.html`<span style=${{
    background,
    color,
    padding,
    borderRadius,
    fontWeight,
    fontFamily,
    ...rest
  }}>${content}</span>`;
}
// https://observablehq.com/@mbostock/scrubber
function Scrubber(values, {
  format = value => value,
  initial = 0,
  direction = 1,
  delay = null,
  autoplay = true,
  loop = true,
  loopDelay = null,
  alternate = false,
  inputStyle = ""
} = {}) {
  values = Array.from(values);
  const form = html`<form style="font: 18px var(--monospace); font-variant-numeric: tabular-nums; display: flex; height: 33px; align-items: center;">
  <button name=b type=button style="margin-right: 0.4em; width: 5em;"></button>
  <label style="display: flex; align-items: center;">
    <input name=i type=range min=0 max=${values.length - 1} value=${initial} step=1 style=${inputStyle}>
    <output name=o style="margin-left: 0.4em;"></output>
  </label>
</form>`;
  let frame = null;
  let timer = null;
  let interval = null;
  function start() {
    form.b.textContent = "Stop";
    if (delay === null) frame = requestAnimationFrame(tick);
    else interval = setInterval(tick, delay);
  }
  function stop() {
    form.b.textContent = "Play";
    if (frame !== null) cancelAnimationFrame(frame), frame = null;
    if (timer !== null) clearTimeout(timer), timer = null;
    if (interval !== null) clearInterval(interval), interval = null;
  }
  function running() {
    return frame !== null || timer !== null || interval !== null;
  }
  function tick() {
    if (form.i.valueAsNumber === (direction > 0 ? values.length - 1 : direction < 0 ? 0 : NaN)) {
      if (!loop) return stop();
      if (alternate) direction = -direction;
      if (loopDelay !== null) {
        if (frame !== null) cancelAnimationFrame(frame), frame = null;
        if (interval !== null) clearInterval(interval), interval = null;
        timer = setTimeout(() => (step(), start()), loopDelay);
        return;
      }
    }
    if (delay === null) frame = requestAnimationFrame(tick);
    step();
  }
  function step() {
    form.i.valueAsNumber = (form.i.valueAsNumber + direction + values.length) % values.length;
    form.i.dispatchEvent(new CustomEvent("input", {bubbles: true}));
  }
  form.i.oninput = event => {
    if (event && event.isTrusted && running()) stop();
    form.value = values[form.i.valueAsNumber];
    form.o.value = format(form.value, form.i.valueAsNumber, values);
  };
  form.b.onclick = () => {
    if (running()) return stop();
    direction = alternate && form.i.valueAsNumber === values.length - 1 ? -1 : 1;
    form.i.valueAsNumber = (form.i.valueAsNumber + direction) % values.length;
    form.i.dispatchEvent(new CustomEvent("input", {bubbles: true}));
    start();
  };
  form.i.oninput();
  if (autoplay) start();
  else stop();
  Inputs.disposal(form).then(stop);
  return form;
}
numbers = Array.from({length: 1000}, (_, i) => i)
hueDeg = Math.round(chosenHsl.h)
hueMtr = Math.round(hueDeg / .36)
hStr = `hsl(${hueDeg}`
slStr = `, ${Math.round(chosenHsl.s * 100)}%, ${Math.round(chosenHsl.l * 100)}%)`
hslStr = hStr + slStr
bkg = ({background: hslStr})
rainbowHue0 = textcolor('hue', bkg)
rainbowHue1 = textcolor('hue', bkg)
rainbowHue2 = textcolor('hue', bkg)
rainbowMtr0 = textcolor(hueMtr, bkg)
rainbowMtr1 = textcolor(hueMtr, bkg)
rainbowDir = textcolor(turn2comp(hueMtr), bkg)
rainbowDeg = textcolor(hueDeg, bkg)
rainbowD3 = d3.hsl(...Object.values(chosenHsl))
rainbowHex = textcolor(d3.hsl(Math.round(chosenHsl.h), chosenHsl.s, chosenHsl.l).formatHex().slice(1), bkg)
// https://observablehq.com/@d3/hcl-color-picker
function picker(model, channels, color) {
  // Specify the picker‚Äôs dimensions.
  // const width = 928; // set by Observable to the window‚Äôs width, for a responsive chart
  const height = 70;
  channels = channels.map(({ name, domain }) => ({
    name,
    scale: d3.scaleLinear().domain(domain).range([0, width]),
    removeLastTick: domain[1]===100 || domain[1]===1
  }));
  // Start from the passed color (present after, e.g., a window resize event), or the midpoint.
  for (const d of channels) d.x = Math.round(color ? d.scale(color[d.name]) : width / 2);
  const wrapper = d3.create("div");
  const white = d3.rgb("white");
  const black = d3.rgb("black");
  const channel = wrapper.selectAll("div").data(channels).join("div");
  const ctx = d3.local();
  const canvas = channel
    .append("canvas")
    .attr("width", width)
    .attr("height", 1)
    .style("max-width", "100%")
    .style("width", `${width}px`)
    .style("height", `${height}px`)
    .each(function (d) {
      const context = this.getContext("2d");
      const image = context.createImageData(width, 1);
      ctx.set(this, { context, image, data: image.data });
    })
    .each(render);
  //const svg = channel
   // .append("svg")
   // .attr("width", width)
   //  .attr("height", 20)
   //  .attr("viewBox", [0, 0, width, 20])
   //  .style("max-width", "100%")
   //  .style("overflow", "visible")
    //.append("g")
    //.each(function (d) {
    //  d3.select(this).call(
    //    d3.axisBottom(d.scale).ticks(Math.min(width / 80, 10))
    //  );
    //  if (d.removeLastTick) d3.select(this).select("g:last-of-type").remove();
    //})
    //.append("text")
    //.attr("x", width)
    //.attr("y", 9)
    //.attr("dy", ".72em")
    //.style("text-anchor", "middle")
    //.style("text-transform", "uppercase")
    //.attr("fill", "currentColor")
    //.text((d) => d.name);
  canvas.call(
    d3.drag()
      .subject(({x}) => ({x}))
      .on("start drag", ({x}, d) => {
        d.x = Math.max(1, Math.min(width - 1, x));
        canvas.each(render);
      })
  );
  function render(d) {
    const current = d3[model](
      channels[0].scale.invert(channels[0].x),
      channels[1].scale.invert(channels[1].x),
      channels[2].scale.invert(channels[2].x)
    );
    // Update the value of the cell and notify listeners (for example, this informs the ‚Äúcolor‚Äù cell below).
    if (d.name === "h") {
      wrapper.node().value = current.copy();
      wrapper.node().dispatchEvent(new Event("input"));
    }
    const { context, image, data } = ctx.get(this);
    for (let x = 0, i = -1; x < width; ++x) {
      const c = x === d.x ? white
              : x === d.x - 1 ? black
              : ((current[d.name] = d.scale.invert(x)), d3.rgb(current));
      data[++i] = c.r;
      data[++i] = c.g;
      data[++i] = c.b;
      data[++i] = 255;
    }
    context.putImageData(image, 0, 0);
  }
  return wrapper.node();
}
// https://observablehq.com/@observablehq/synchronized-inputs
// https://observablehq.com/@juang1744/transform-input/1
transformInput = function(target, {bind: source, transform = identity, involutory = false, invert = involutory ? transform : inverse(transform)} = {}){
  if (source === undefined) {
    source = target;
    target = html`<div>${source}</div>`;
  }
  function sourceInputHandler() {
    target.removeEventListener("input", targetInputHandler);
    setTransform(target).to(transform(source.value)).andDispatchEvent();
    target.addEventListener("input", targetInputHandler);
  }
  function targetInputHandler() {
    source.removeEventListener("input", sourceInputHandler);
    setTransform(source).to(invert(target.value)).andDispatchEvent();
    source.addEventListener("input", sourceInputHandler);
  }
  source.addEventListener("input", sourceInputHandler);
  target.addEventListener("input", targetInputHandler);
  invalidation.then(() => {
    source.removeEventListener("input", sourceInputHandler);
    target.removeEventListener("input", targetInputHandler);
  });
  sourceInputHandler();
  return target;
}
setTransform = (input) => ({to: (value) => (input.value = value, {andDispatchEvent: (event = new Event("input")) => input.dispatchEvent(event)})});
function inverse(f) {
  switch (f) {
    case identity:  return identity;
    case Math.sqrt: return square;
    case Math.log:  return Math.exp;
    case Math.exp:  return Math.log;
    default:        return (x => solve(f, x, x));
  }
  function solve(f, y, x = 0) {
    const dx = 1e-6;
    let steps = 100, deltax, fx, dfx;
    do {
      fx = f(x)
      dfx = (f(x + dx) - fx) || dx;
      deltax = dx * (fx - y)/dfx
      x -= deltax;
    } while (Math.abs(deltax) > dx && --steps > 0);
    return steps === 0 ? NaN : x;
  }
function square(x) {
    return x * x;
  }
}
function identity(x) {
  return x;
}
// http://howardhinnant.github.io/date_algorithms.html#civil_from_days
function unix2dote(unix, zone, offset = 719468) {
  return [(unix ?? Date.now()) / 86400000 + (
    zone = zone ?? -Math.round(
      (new Date).getTimezoneOffset() / 144)
    ) / 10 + offset, zone]
}
function dote2date(dote, zone = 0) {
  const cote = Math.floor((
      dote >= 0 ? dote
      : dote - 146096
    ) / 146097),
  dotc = dote - cote * 146097,
  yotc = Math.floor((dotc
    - Math.floor(dotc / 1460)
    + Math.floor(dotc / 36524)
    - Math.floor(dotc / 146096)
  ) / 365);
  return [
    yotc + cote * 400,
    dotc - (yotc * 365
      + Math.floor(yotc / 4)
      - Math.floor(yotc / 100)
  ), zone]}
dz = unix2dote(now, 0)
ydz = dote2date(...dz)
decYear = ydz[0]
decDate = Math.floor(ydz[1])
decTime = ydz[1] % 1
decDek = Math.floor(decDate / 10)
decDod = decDate % 10
decMoty = Math.floor((5 * decDate + 2) / 153)
decDotm = Math.floor(decDate - (153 * decMoty + 2) / 5 + 1)
isoYear = decYear + (decMoty > 9)
month = decMoty < 10 ? decMoty + 3 : decMoty - 9
decHour = decTime * 24
decMinute = (decHour % 1) * 60
decSecond = (decMinute % 1) * 60
isoHour = Math.floor(decHour)
isoMinute = Math.floor(decMinute)
isoSecond = Math.floor(decSecond)
isLeap = decYear % 4 == 0 && decYear % 100 != 0 || decYear % 400 == 0;
timezones = FileAttachment("../asset/timezones.json").json()
zones = topojson.feature(timezones, timezones.objects.timezones).features
mesh = topojson.mesh(timezones, timezones.objects.timezones)
color = d3.scaleSequential(d3.interpolateRdBu).domain([14, -12])
// https://observablehq.com/@enjalot/draggable-world-map-coordinates-input
function worldMapCoordinates(config = {}, dimensions) {
  const {
    value = [], title, description, width = dimensions[0]
  } = Array.isArray(config) ? {value: config} : config;
  const height = dimensions[1];
  let [lon, lat] = value;
  lon = lon != null ? lon : null;
  lat = lat != null ? lat : null;
  const formEl = html`<form style="width: ${width}px;"></form>`;
  const context = DOM.context2d(width, height);
  const canvas = context.canvas;
  canvas.style.margin = `-4px 0 ${width > 400 ? -8 : -14}px`;
  const projection = config[2]
    .precision(0.1)
    .fitSize([width, height], { type: "Sphere" }).rotate([-156, 0]);
  const path = d3.geoPath(projection, context).pointRadius(2.5);
  formEl.append(canvas);
  function fillMesh(f) {
    context.beginPath();
    path(f);
    context.fillStyle = color(f.properties.zone);
    context.fill();
  }
  function draw() {
    if (!utctoggle) {
      context.beginPath(); path({type: "Sphere"});
      context.fillStyle = mapcolors.ocean; context.fill();
    }
    if (utctoggle) {
      zones.map(f => fillMesh(f))
    }
    context.beginPath();
    path(land);
    if (!utctoggle) {
      context.fillStyle = mapcolors.land;
      context.fill();
    }
    context.strokeStyle = `#888`;
    context.stroke();
    if (border) {
      context.beginPath();
      path(borders);
      context.lineWidth = 1.25;
      context.strokeStyle = `#888`;
      context.stroke();
    }
    if (utctoggle) {
      context.beginPath();
      path(mesh);
      context.lineWidth = 1.25;
      context.strokeStyle = `#aaa`;
      context.stroke();
    }
    if (dectoggle) {
      context.beginPath();
      path(graticule);
      context.lineWidth = 1.25;
      context.strokeStyle = `#000`;
      context.stroke();
      context.font = width < 760 ? "12px serif" : "21px serif";
      context.fillStyle = `#000`;
      d3.range(-1.5, 342 + 1, 36).map(x =>  context.fillText(long2zone(x), ...projection([x, 27.5])));
      d3.range(-1.5, 342 + 1, 36).map(x =>  context.fillText(long2zone(x), ...projection([x, -48])));
      // d3.range(-18, 336 + 1, 36).map(x => context.fillText(formatLongitude(x), ...projection([x, 90])));
      // d3.range(-18, 336 + 1, 36).map(x => context.fillText(formatLongitude(x), ...projection([x, -90])));
    }
    if (suntoggle) {
      context.beginPath();
      path(night);
      context.fillStyle = "rgba(0,0,255,0.15)";
      context.fill();
      context.beginPath();
      path.pointRadius(18);
      path({type: "Point", coordinates: sun});
      context.strokeStyle = "#0009";
      context.fillStyle = "#ff0b";
      context.lineWidth = 1;
      context.stroke();
      context.fill();
    }
  }
  draw();
  return formEl;
}
// https://observablehq.com/@fil/d3-projections
projections = [
  { name: "Airocean", value: d3.geoAirocean },
  { name: "Airy‚Äôs minimum error", value: d3.geoAiry },
  { name: "Aitoff", value: d3.geoAitoff },
  { name: "American polyconic", value: d3.geoPolyconic },
  { name: "Armadillo", value: d3.geoArmadillo, options: { clip: { type: "Sphere" } } },
  { name: "August", value: d3.geoAugust },
  { name: "azimuthal equal-area", value: d3.geoAzimuthalEqualArea },
  { name: "azimuthal equidistant", value: d3.geoAzimuthalEquidistant },
  { name: "Baker dinomic", value: d3.geoBaker },
  { name: "Berghaus‚Äô star", value: d3.geoBerghaus, options: { clip: { type: "Sphere" } } },
  { name: "Bertin‚Äôs 1953", value: d3.geoBertin1953 },
  { name: "Boggs‚Äô eumorphic", value: d3.geoBoggs },
  { name: "Boggs‚Äô eumorphic (interrupted)", value: d3.geoInterruptedBoggs, options: { clip: { type: "Sphere" } } },
  { name: "Bonne", value: d3.geoBonne },
  { name: "Bottomley", value: d3.geoBottomley },
  { name: "Bromley", value: d3.geoBromley },
  { name: "Butterfly (gnomonic)", value: d3.geoPolyhedralButterfly },
  { name: "Butterfly (Collignon)", value: d3.geoPolyhedralCollignon },
  { name: "Butterfly (Waterman)", value: d3.geoPolyhedralWaterman },
  { name: "Cahill-Keyes", value: d3.geoCahillKeyes },
  { name: "Collignon", value: d3.geoCollignon },
  { name: "conic equal-area", value: d3.geoConicEqualArea },
  { name: "conic equidistant", value: d3.geoConicEquidistant },
  { name: "Craig retroazimuthal", value: d3.geoCraig },
  { name: "Craster parabolic", value: d3.geoCraster },
  { name: "Cox", value: d3.geoCox },
  { name: "cubic", value: d3.geoCubic },
  { name: "cylindrical equal-area", value: d3.geoCylindricalEqualArea },
  { name: "cylindrical stereographic", value: d3.geoCylindricalStereographic },
  { name: "dodecahedral", value: d3.geoDodecahedral },
  { name: "Eckert I", value: d3.geoEckert1 },
  { name: "Eckert II", value: d3.geoEckert2 },
  { name: "Eckert III", value: d3.geoEckert3 },
  { name: "Eckert IV", value: d3.geoEckert4 },
  { name: "Eckert V", value: d3.geoEckert5 },
  { name: "Eckert VI", value: d3.geoEckert6 },
  { name: "Eisenlohr conformal", value: d3.geoEisenlohr },
  { name: "Equal Earth", value: d3.geoEqualEarth },
  { name: "Equirectangular (plate carr√©e)", value: d3.geoEquirectangular },
  { name: "Fahey pseudocylindrical", value: d3.geoFahey },
  { name: "flat-polar parabolic", value: d3.geoMtFlatPolarParabolic },
  { name: "flat-polar quartic", value: d3.geoMtFlatPolarQuartic },
  { name: "flat-polar sinusoidal", value: d3.geoMtFlatPolarSinusoidal },
  { name: "Foucaut‚Äôs stereographic equivalent", value: d3.geoFoucaut },
  { name: "Foucaut‚Äôs sinusoidal", value: d3.geoFoucautSinusoidal },
  { name: "general perspective", value: d3.geoSatellite },
  { name: "Gingery", value: d3.geoGingery, options: { clip: { type: "Sphere" } } },
  { name: "Ginzburg V", value: d3.geoGinzburg5 },
  { name: "Ginzburg VI", value: d3.geoGinzburg6 },
  { name: "Ginzburg VIII", value: d3.geoGinzburg8 },
  { name: "Ginzburg IX", value: d3.geoGinzburg9 },
  { name: "Goode‚Äôs homolosine", value: d3.geoHomolosine},
  { name: "Goode‚Äôs homolosine (interrupted)", value: d3.geoInterruptedHomolosine, options: { clip: { type: "Sphere" } }  },
  { name: "gnomonic", value: d3.geoGnomonic },
  { name: "Gringorten square", value: d3.geoGringorten },
  { name: "Gringorten quincuncial", value: d3.geoGringortenQuincuncial },
  { name: "Guyou square", value: d3.geoGuyou },
  { name: "Hammer", value: d3.geoHammer },
  { name: "Hammer retroazimuthal", value: d3.geoHammerRetroazimuthal, options: { clip: { type: "Sphere" } } },
  { name: "HEALPix", value: d3.geoHealpix, options: { clip: { type: "Sphere" } } },
  { name: "Hill eucyclic", value: d3.geoHill },
  { name: "Hufnagel pseudocylindrical", value: d3.geoHufnagel },
  { name: "icosahedral", value: d3.geoIcosahedral },
  { name: "Imago", value: d3.geoImago },
  { name: "Kavrayskiy VII", value: d3.geoKavrayskiy7 },
  { name: "Lagrange conformal", value: d3.geoLagrange },
  { name: "Larriv√©e", value: d3.geoLarrivee },
  { name: "Laskowski tri-optimal", value: d3.geoLaskowski },
  { name: "Loximuthal", value: d3.geoLoximuthal },
  { name: "Mercator", value: d3.geoMercator },
  { name: "Miller cylindrical", value: d3.geoMiller },
  { name: "Mollweide", value: d3.geoMollweide },
  { name: "Mollweide (Goode‚Äôs interrupted)", value: d3.geoInterruptedMollweide, options: { clip: { type: "Sphere" } } },
  { name: "Mollweide (interrupted hemispheres)", value: d3.geoInterruptedMollweideHemispheres, options: { clip: { type: "Sphere" } } },
  { name: "Natural Earth", value: d3.geoNaturalEarth1 },
  { name: "Natural Earth II", value: d3.geoNaturalEarth2 },
  { name: "Nell‚ÄìHammer", value: d3.geoNellHammer },
  { name: "Nicolosi globular", value: d3.geoNicolosi },
  { name: "orthographic", value: d3.geoOrthographic },
  { name: "Patterson cylindrical", value: d3.geoPatterson },
  { name: "Peirce quincuncial", value: d3.geoPeirceQuincuncial },
  { name: "rectangular polyconic", value: d3.geoRectangularPolyconic },
  { name: "Robinson", value: d3.geoRobinson },
  { name: "sinusoidal", value: d3.geoSinusoidal },
  { name: "sinusoidal (interrupted)", value: d3.geoInterruptedSinusoidal, options: { clip: { type: "Sphere" } } },
  { name: "sinu-Mollweide", value: d3.geoSinuMollweide },
  { name: "sinu-Mollweide (interrupted)", value: d3.geoInterruptedSinuMollweide, options: { clip: { type: "Sphere" } } },
  { name: "stereographic", value: d3.geoStereographic },
  { name: "Lee‚Äôs tetrahedal", value: d3.geoTetrahedralLee },
  { name: "Times", value: d3.geoTimes },
  { name: "Tobler hyperelliptical", value: d3.geoHyperelliptical },
  { name: "transverse Mercator", value: d3.geoTransverseMercator },
  { name: "Van der Grinten", value: d3.geoVanDerGrinten },
  { name: "Van der Grinten II", value: d3.geoVanDerGrinten2 },
  { name: "Van der Grinten III", value: d3.geoVanDerGrinten3 },
  { name: "Van der Grinten IV", value: d3.geoVanDerGrinten4 },
  { name: "Wagner IV", value: d3.geoWagner4 },
  { name: "Wagner VI", value: d3.geoWagner6 },
  { name: "Wagner VII", value: d3.geoWagner7 },
  { name: "Werner", value: d3.geoBonne ? () => d3.geoBonne().parallel(90) : null },
  { name: "Wiechel", value: d3.geoWiechel },
  { name: "Winkel tripel", value: d3.geoWinkel3 }
]
mapcolors = ({
  night: "#719fb6",
  day: "#ffe438",
  grid: "#4b6a79",
  ocean: "#adeeff",
  land: "#90ff78",
  sun: "#ffe438"
})
function long2turn(degrees = -180, e = 3) {
  // turns: e=0, deciturns: e=1, etc.
  return (((degrees %= 360) < 0 ? degrees + 360 : degrees) + 18) / (360 / 10**e) % 10**e;
}
function long2zone(degrees = -180) { return Math.floor(long2turn(degrees, 1)); }
projection = select ? select.value() : d3.geoEquirectangular()
sun = {
  const now = new Date;
  const day = new Date(+now).setUTCHours(0, 0, 0, 0);
  const t = solar.century(now);
  const longitude = (day - now) / 864e5 * 360 - 180;
  return [longitude - solar.equationOfTime(t) / 4, solar.declination(t)];
}
night = d3.geoCircle().radius(90).center(antipode(sun))()
antipode = ([longitude, latitude]) => [longitude + 180, -latitude]
height = {
  const [[x0, y0], [x1, y1]] = d3.geoPath(projection.fitWidth(width, sphere)).bounds(sphere);
  const dy = Math.ceil(y1 - y0), l = Math.min(Math.ceil(x1 - x0), dy);
  projection.scale(projection.scale() * (l - 1) / l).precision(0.2);
  return dy;
}
d3 = require("d3@6", "d3-array@3", "d3-geo@3", "d3-geo-projection@4", "d3-geo-polygon@1.8")
sphere = ({type: "Sphere"})
graticule = d3.geoGraticule().stepMinor([36,0]).stepMajor([36,0])()
graticule.coordinates = graticule.coordinates.map(
  i => i.map(j => j.map((k, index, arr) => i.length === 3 && index === 0 ? k - 18 : k))
)
land = topojson.feature(world, world.objects.land)
world = fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/land-50m.json").then(response => response.json())
topojson = require("topojson-client@3")
solar = require("solar-calculator@0.3/dist/solar-calculator.min.js")
borders = topojson.mesh(countries, countries.objects.countries, (a, b) => a !== b)
countries = fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-50m.json").then(response => response.json())
piecolors = [
  "#ff4000", // 15
  "#ff8000", // 30
  "#ffbf00", // 45
  "#ffff00", // 60
  '#bfff00', // 75
  '#80ff00', // 90
  '#40ff00', // 105
  '#00ff00', // 120
  '#00ff40', // 135
  '#00ff80', // 150
  '#00ffbf', // 165
  '#00ffff', // 180
  '#00bfff', // 195
  '#0080ff', // 210
  '#0040ff', // 225
  '#0000ff', // 240
  '#4000ff', // 255
  '#8000ff', // 270
  '#bf00ff', // 285
  '#ff00ff', // 300
  '#ff00bf', // 315
  '#ff0080', // 330
  '#ff0040', // 345
  '#f00',    // 0
]
viewof size = Inputs.range([50, 700], {
  value: 300,
  step: 20,
  label: 'size'
})
viewof numMajorTicks = Inputs.range([0, 45], {
  value: 6,
  step: 2,
  label: "Major ticks"
})
viewof numMinorTicks = Inputs.range([0, 10], {
  value: 4,
  step: 1,
  label: "Minor ticks"
})
function repeat(component, N, initialAngle=0) {
  // NOTE: if component is a function, it will be called with (angle, i)
  if (N <= 0) return "";
  let result = [];
  for (let i = 0; i < N; i++) {
    let angle = (360 / N) * i + initialAngle;
    let el = typeof component === 'function'? component(angle, i) : component;
    result.push(`<g transform="rotate(${angle})">${el}</g>`);
  }
  return result.join("");
}
function tick(radius, length, color='black') {
  return `<path d="M 0,${-radius} l 0,${-length}" fill="none" stroke="${color}" stroke-width="1" />`;
}
function directionMarker(radius, fontSize) { return (angle, _) => {
  let label = {0: 'N', 45: 'NE', 90: 'E', 135: 'SE', 180: 'S', 225: 'SW', 270: 'W', 315: 'NW'}[angle] ?? '??';
  return `<text y="${-radius-(margin/2)}" font-size="${fontSize}" text-anchor="middle" dy=".36em">${label}</text>`;
};
}
function turnMarker(radius, fontSize) { return (angle, _) => {
  let label = {0: '0', 45: '125', 90: '250', 135: '375', 180: '500', 225: '625', 270: '750', 315: '875'}[angle] ?? '??';
  return `<text y="${-radius-(margin/2)}" font-size="${fontSize}" text-anchor="middle" dy="-0.36em">${label}</text>`;
  };
}
function pie(radius, width, narrowness=1.0, piecolors) {
  return (_, i) => `<path id="piepath" d="M 0,0 L ${-width},${-radius} A ${width} ${width/2} 0 0 1 ${width} ${-radius} z" fill="${piecolors[i]}" stroke="black" stroke-width="0.5"/>`;
}
margin = size / 14
padding = 42
radius = size/2 - margin - padding
```

```{=html}
<style>
div#colorslider {
  display: flex;
}
div#colorslider input[type="number"] {
  width: 80px;
}
div#colorwheelcompass {
  display: flex;
  justify-content: center;
}
div#zonemap {
   overflow-y: hidden;
   margin-top: -15px;
}
div#toggles {
   display: flex;
}
div#toggles form.oi-3a86ea-toggle > label {
   width: 28px;
}
div#toggles form.oi-3a86ea-toggle > label[for="oi-3a86ea-3"] {
  width: 56px;
}
div#toggles form.oi-3a86ea-toggle > label[for="oi-3a86ea-2"] {
  width: 46px;
}
div#toggles form.oi-3a86ea-toggle > label[for="oi-3a86ea-1"] {
  width: 31px;
}
div#toggles  form.oi-3a86ea-toggle {
   width: 110px;
}
div#toggles  input.oi-3a86ea-input[type="checkbox"] {
  margin: 3px 0px 0px 0px;
}
div#projselect form.oi-3a86ea > label {
   --label-width: 80px;
}
div#projselect form.oi-3a86ea {
   --input-width: 260px;
}
div:has(div.description) {
  display: none;
}
</style>
```
