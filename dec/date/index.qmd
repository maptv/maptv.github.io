---
title: Dec Date
image: /asset/deidek.svg
citation:
  url: https://maptv.github.io/dec/date
license: CC BY-SA
lightbox: false
toc: true
toc-depth: 4
format:
  html:
    shift-heading-level-by: 3
    include-after-body:
      - ../../asset/cite.html
      - ../../asset/style.html
      - ../../asset/stamp.html
      - ../../asset/tooltip.html
  commonmark: default
filters:
  - ../../asset/date.lua
  - include-code-files
---

My website serves as a demonstration of both the [Quarto](https://quarto.org) publishing system and the [Dec](/dec) measurement system. I use several clever hacks to get Quarto to display all of the dates on my website in the Dec [year]{.yellow}+[day]{.cyan} format. Knowing the basics of Dec dates will help you to understand the articles on [filter](https://quarto.org/docs/extensions/filters.html), [script](https://quarto.org/docs/projects/scripts.html), and [include](https://quarto.org/docs/output-formats/html-basics.html#includes) files in the [Quarto section](/quarto) of my site.

Among its many features, Quarto offers support for the [Observable](https://observablehq.com/) data analysis and visualization system. In the Observable [calendarüóìÔ∏èplots](https://observablehq.com/@observablehq/plot-calendar) below, [Gregorian calendar](https://en.wikipedia.org/wiki/Gregorian_calendar#:~:text=the%20calendar%20used%20in%20most%20parts%20of%20the%20world) months are identified by [color](https://observablehq.com/@d3/color-schemes) and each day of the year has its own [cell](https://observablehq.com/plot/marks/cell). Despite these similarities, the two plots illustrate how the Dec (top) and Gregorian (bottom) calendars differ.

# Doy

The Dec calendar (Decalendar) starts on [Day 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="March 1"} instead of [Day 306]{.underline .tool data-bs-toggle="tooltip" data-bs-title="January 1"} and uses a single number called the day-of-year (doy), the [day]{.cyan} in [year]{.yellow}+[day]{.cyan}, to serve the same purpose as months and weeks in the Gregorian calendar. The current doy and the doy selected by the [Observable](https://observablehq.com/) [range](https://observablehq.com/@observablehq/input-range)üéöÔ∏èinputs below to be highlighted in the calendarüóìÔ∏èplots are [\${decoDoty}]{.cyan} and [\${dotyInput}]{.cyan}, respectively.

::: {.column-page-right}
```{ojs}
//| echo: false
decPlot = Plot.plot({
  padding: 0,
  width: 1080,
  height: 240,
  className: "calplot",
  marginTop: -3,
  marginLeft: 31,
  marginBottom: 35,
  y: {tickSize: 0,
      label: "Day of the dek    ",
      domain: [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      ticks: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      tickPadding: -12,
      labelOffset: 22,
  },
  x: {interval: 1, ticks: 18, label: "Dek", type: "band", tickSize: 0, tickPadding: -2, labelOffset: 32},
  //fx: {tickFormat: ""},
  style: { fontSize: "21px" },
  color: {
    range: d3.schemePastel1.concat(d3.schemePastel2.slice(4, 7)).concat(d3.schemeSet1[0]),
    domain: months.concat("selected"),
    className: "cal",
  },
  marks: [
    Plot.cell(dates, {
      x: (d, i) => Math.floor(i / 10),
      y: (d, i) => i % 10,
      //fx: d => d.getUTCFullYear(),
      fill: d => Math.floor(unix2doty(d.getTime())) === dotyInput ? "selected" : months[d.getUTCMonth()],
      stroke: d => Math.floor(unix2doty(d.getTime())) === dotyInput ? "darkorange" : "none",
      strokeWidth: 3,
      inset: 0.5,
    }),
    Plot.text(dates, {
      x: (d, i) => Math.floor(i / 10),
      y: (d, i) => i % 10,
      //fx: d => d.getUTCFullYear(),
      text: d => d.getUTCDate() === 7 ? months[d.getUTCMonth()].slice(0, 3) : "",
      y: -1,
      frameAnchor: "left",
      dy: -1,
      monospace: true,
      fontSize: "18px"}),
    Plot.text(dates, {
      x: (d, i) => Math.floor(i / 10),
      y: (d, i) => i % 10,
      //fx: d => d.getUTCFullYear(),
      fill: d => Math.floor(unix2doty(d.getTime())) === dotyInput ? "white" : "black",
      //stroke: "white",
      text: (d, i) => String(i),//.padStart(3, "0").slice(1),
      monospace: true,
      fontSize: "13px"})
  ]
})
```

```{ojs}
//| echo: false
calPlot = Plot.plot({
  padding: 0,
  width: 1000,
  height: 200,
  className: "calplot",
  marginTop: 0,
  marginBottom: 40,
  marginLeft: 42,
  y: {tickFormat: Plot.formatWeekday("en", "short"), tickSize: 0,
      domain: [-1, 0, 1, 2, 3, 4, 5, 6],
      ticks: [0, 1, 2, 3, 4, 5, 6],
      tickPadding: 2,
  },
  x: {interval: 1, ticks: 26, label: "Week", type: "band", tickSize: 0, tickPadding: 2, labelOffset: 36},
  //fx: {tickFormat: ""},
  style: { fontSize: "20px" },
  color: {
    range: d3.schemePastel1.concat(d3.schemePastel2.slice(4, 7)).concat(d3.schemeSet1[0]),
    domain: months.concat("selected"),
    className: "cal",
  },
  marks: [
    Plot.cell(datesCal, {
      x: d => d3.utcWeek.count(d3.utcYear(d), d),
      y: d => d.getUTCDay(),
      //fx: d => d.getUTCFullYear(),
      fill: d => Math.floor(unix2doty(d.getTime())) === dotyInput ? "selected" : months[d.getUTCMonth()],
      stroke: d => Math.floor(unix2doty(d.getTime())) === dotyInput ? "darkorange" : "none",
      strokeWidth: 3,
      inset: .5,
    }),
    Plot.text(datesCal, {
      x: d => d3.utcWeek.count(d3.utcYear(d), d),
      y: d => d.getUTCDay(),
      //fx: d => d.getUTCFullYear(),
      text: d => d.getUTCDate() === 7 ? months[d.getUTCMonth()].slice(0, 3) : "",
      y: -1,
      frameAnchor: "left",
      dy: -1,
      monospace: true,
      fontSize: "18px"}),
    Plot.text(datesCal, {
      x: d => d3.utcWeek.count(d3.utcYear(d), d),
      y: d => d.getUTCDay(),
      //fx: d => d.getUTCFullYear(),
      fill: d => Math.floor(unix2doty(d.getTime())) === dotyInput ? "white" : "black",
      //stroke: "white",
      text: d => d.getUTCDate(), //Math.floor(unix2doty(d.getTime())).toString().padStart(3, "0"),
      monospace: true,
      fontSize: "13px"})
  ]
})
```
:::

```{ojs}
//| echo: false
viewof dotyInput = Inputs.range([0, 364 + leapInput], {value: 306, step: 1, label: "Day of the year"});
viewof monthInput = transformInput(
  Inputs.range([1, 12], {step: 1, label: "Month"}),
  {bind: viewof dotyInput, transform: doty2month, invert: month2doty}
);
viewof dotyInput1 = transformInput(
  Inputs.range([-365 - leapInput, -1], {step: 1, label: "Day of the year"}),
  {bind: viewof dotyInput, transform: subN, invert: addN}
);
viewof dotmInput = transformInput(
  Inputs.range([1, 31], {step: 1, label: "Day of the month"}),
  {bind: viewof dotyInput, transform: doty2dotm, invert: (x => Math.floor(( 153 * (
    viewof monthInput.value > 2
    ? viewof monthInput.value - 3
    : viewof monthInput.value + 9) + 2
  ) / 5 + x - 1
))});
viewof leapscrub = Inputs.form([
  Scrubber(numbers, {autoplay: false, alternate: true, delay: 86.4, loopDelay: 864, format: y => "", inputStyle: "display:none;"}),
  Inputs.toggle({label: "Leap year", value: false}),
])
```

[First day of the Gregorian calendar year]{.radiotitle}

```{ojs}
//| echo: false
viewof dotwInput = Inputs.radio([
  "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday",
  ], {value: "Sunday"})
```

There are two rangeüéöÔ∏èinputs labeled as "day of the year" because every doy can be expressed as both a positive and a negative number.
The typical range for doys is 0 to [n]{.orange}-1, but negative doys typically range from -[n]{.orange} to -1, where [n]{.orange} is the number of days in the year. A doy outside these [bounds](https://en.wikipedia.org/wiki/Upper_and_lower_bounds#:~:text=an%20upper%20bound%20or%20majorant%5B1%5D%20of%20a%20subset%20S%20of%20some%20preordered%20set%20(K%2C%20%E2%89%A4)%20is%20an%20element%20of%20K%20that%20is%20greater%20than%20or%20equal%20to%20every%20element%20of%20S.%5B2%5D%5B3%5D%20Dually%2C%20a%20lower%20bound%20or%20minorant%20of%20S%20is%20defined%20to%20be%20an%20element%20of%20K%20that%20is%20less%20than%20or%20equal%20to%20every%20element%20of%20S) represents a day in a previous or subsequent year.

The Play‚ñ∂Ô∏èbutton above cyclesüîÑthrough every doy, month, and day of the month in the plots so that each day gets its turn to be highlighted with a redüü•background. The appearance of the bottom plot depends on the [toggle](https://observablehq.com/framework/inputs/toggle#:~:text=choose%20one%20of%20two%20values)‚úÖand [radio](https://observablehq.com/framework/inputs/radio#:~:text=choose%20one%20of%20a%20given%20set%20of%20values)üîòinputs, which determine whether [n]{.orange} is 365 (common year) or 366 (leap year) and the day of the week that starts the year, respectively.

The toggle‚úÖinput shifts 306 dates, [Day 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="March 1"} to [Day 305]{.underline .tool data-bs-toggle="tooltip" data-bs-title="December 31"}, in the Gregorian calendar by one day, but does not change the order of any Dec dates, because [leap day](https://en.wikipedia.org/wiki/February_29#:~:text=intercalary%20date%20added%20periodically) ([Day 365]{.underline .tool data-bs-toggle="tooltip" data-bs-title="February 29"}) is the last day of the Dec leap years and the doy resets to zero at the start of every year. The radioüîòinput shifts every Gregorian calendar date by 1 to 6 days, but has no effect on Decalendar whatsoever.

The current doy, [\${decoDoty}]{.cyan}, consists of the current dek, [\${decoDoty.slice(0, 2)}]{.cyan}, and day of the dek, [\${decoDoty[2]}]{.cyan}. Deks are groups of 10 days that are well-aligned with the Dec year. Every Dec year starts on [Day 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="March 1"}, the first day of first dek of the year, Dek 0. Common years end on [Day 364]{.underline .tool data-bs-toggle="tooltip" data-bs-title="February 28"}, exactly halfway through Dek 36, whereas leap years end on the sixth day of Dek 36: [Day 365]{.underline .tool data-bs-toggle="tooltip" data-bs-title="February 29"}.

# Doe

The last day of the year, [Day -1]{.underline .tool data-bs-toggle="tooltip" data-bs-title="February 28 in common years, February 29 in leap years"}, is always followed by [Day 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="March 1"}, regardless of the last 4 or 5 days of Dec 36 that extend past the end of the year. While doys do not count deks past Dek 36, each [year]{.yellow}+[day]{.cyan} date can be converted into an [unbounded](https://en.wikipedia.org/wiki/Bounded_set#:~:text=a%20set%20which%20is%20not%20bounded) count of days since the Dec [epoch](https://en.wikipedia.org/wiki/Epoch#:~:text=an%20instant%20in%20time%20chosen%20as%20the%20origin%20of%20a%20particular%20calendar%20era) ([Year 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="1 BC"} [Day 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="March 1"} [Dot 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="midnight"}) called a day-of-[era](https://en.wikipedia.org/wiki/Calendar_era#:~:text=the%20period%20of%20time%20elapsed%20since%20one%20epoch%20of%20a%20calendar) (doe). , provide an unbroken sequence of deks that is analogous to the weeks in the Gregorian calendar.

Dec uses dotes for calculations, such as finding the [POSIX](https://en.wikipedia.org/wiki/POSIX#:~:text=a%20family%20of%20standards%20specified%20by%20the%20IEEE%20Computer%20Society%20for%20maintaining%20compatibility%20between%20operating%20systems) [Sunday-based](https://pubs.opengroup.org/onlinepubs/007904875/utilities/date.html#:~:text=weekday%20as%20a%20decimal%20number%20%5B0%2C6%5D%20(0%3Dsunday)) day-of-week (dow) of a given date. This year, the dow of ChristmasüéÑis [\${xmasDotw}]{.azul}, according to the Dec dow equation: ([\${xmasDote}]{.cyan} + 3) [mod](https://en.wikipedia.org/wiki/Modulo#:~:text=returns%20the%20remainder) 7 = [\${xmasDotw}]{.azul}. In contrast to the dow, finding the day of the dek (dotd) of a given Dec date does not require any calculation because the dotd is simply the last digit of the doy.

::: {.callout-warning}
# Bad Pun Alert
[Dek the halls](https://en.wikipedia.org/wiki/Deck_the_Halls#:~:text=a%20traditional%20Christmas%20carol.) with boughs of doy! Fa + la &times; 8!
:::

ChristmasüéÑis a fixed holiday because it occurs on the same doy, [Day 299]{.underline .tool data-bs-toggle="tooltip" data-bs-title="December 25"}, every year. Unlike fixed holidays, Gregorian calendar floating holidays happen on a different doy every year so that their dow can remain constant. Dec uses the dow difference equation, [w~Œî~]{.azul} = ([w~M~]{.azul} - [w~S~]{.azul} + 7) [mod](https://en.wikipedia.org/wiki/Modulo#:~:text=returns%20the%20remainder) 7, to determine which of the seven possible floating holiday dates corresponds to the given year.

In the dow difference equation, [w~M~]{.azul} is the [minuend](https://en.wiktionary.org/wiki/minuend#:~:text=A%20number%20or%20quantity%20from%20which%20another%20is%20to%20be%20subtracted) dow at which we want to arrive and [w~S~]{.azul} is [subtrahend](https://en.wikipedia.org/wiki/Subtraction#:~:text=number%20being%20subtracted) dow from which we start. To get the doy of [Thanksgiving](https://en.wikipedia.org/wiki/Thanksgiving#:~:text=Thanksgiving%20is-,a%20national%20holiday,-celebrated%20on%20various)ü¶Éin the United States and Brazil, we plug [4]{.azul} as [w~M~]{.azul} and [\${day266dotw}]{.azul}, the dow of [Day 266]{.underline .tool data-bs-toggle="tooltip" data-bs-title="November 22"} this year, as [w~S~]{.azul} into the dow difference equation, [\${day266dotwDiff}]{.azul} = ([4]{.azul} - [\${day266dotw}]{.azul} + 7) [mod](https://en.wikipedia.org/wiki/Modulo#:~:text=returns%20the%20remainder) 7, and then add the resulting [w~Œî~]{.azul} to 266: [\${day266dotwDiff + 266}]{.cyan} = [\${day266dotwDiff}]{.azul} + 266.

Apart from the dow and dow difference equations, the Thanksgivingü¶Écalculation above relies on the Dec dote equation, which is based on the [`days_from_civil`](https://howardhinnant.github.io/date_algorithms.html#days_from_civil){.mono} algorithm created by [Howard Hinnant](https://howardhinnant.github.io) and described in his manuscript entitled [[`chrono`]{.mono}-Compatible Low-Level Date Algorithms](https://howardhinnant.github.io/date_algorithms.html), to convert the  [cycle](https://en.wikipedia.org/wiki/Solar_cycle_(calendar)#:~:text=the%20Gregorian%20cycle%20of%20400%20years%20has%20exactly%20146%2C097%20days%2C%20i.e.%20exactly%2020%2C871%20weeks%2C%20one%20can%20say%20that%20the%20Gregorian%20so%2Dcalled%20solar%20cycle%20lasts%20400%20years)-of-era (coe), year-of-cycle (yoc), and doy of [Day 266]{.underline .tool data-bs-toggle="tooltip" data-bs-title="November 22"} into its dote:

:::{style="overflow-x:auto;overflow-y:hidden;"}
$$\text{coe} = \Biggl \lfloor \frac{\begin{cases}\text{year}&{\text{if } \text{year} \geq 0;}\\\text{year}-399&{\text{otherwise.}}\end{cases}}{400} \Biggr \rfloor$$

$$\text{yoc} = \text{year} - \text{coe} \times 400$$

$$\text{dote} = \text{coe}\times146097 + \text{yoc}\times365 + \lfloor\frac{\text{yoc}}{4}\rfloor - \lfloor\frac{\text{yoc}}{100}\rfloor + \text{doty}$$
:::

The Dec date equations, the [inverse](https://en.wikipedia.org/wiki/Inverse#:~:text=Inverse%20function%2C-,a%20function%20that%20%22reverses%22%20another%20function,-Generalized%20inverse%2C%20a)üîÅof the Dec dote equation above, are based on Howard Hinnant's [`days_from_civil`](https://howardhinnant.github.io/date_algorithms.html#days_from_civil){.mono} algorithm and is useful for obtaining Dec dates from dotes and dote equivalents like [Unix timestamps](https://en.wikipedia.org/wiki/Unix_time#:~:text=the%20number%20of%20seconds%20that%20have%20elapsed%20since%2000%3A00%3A00%20UTC%20on%201%C2%A0January%201970) and [Julian days](https://en.wikipedia.org/wiki/Julian_day#:~:text=a%20continuous%20count%20of%20days%20from%20the%20beginning%20of%20the%20Julian%20period). Apart from coe and yoc, the Dec date equations use the day-of-cycle (doc) of a dote to produce the dote's corresponding year and doy:

:::{style="overflow-x:auto;overflow-y:hidden;"}
$$\text{coe} = \Biggl \lfloor \frac{\begin{cases}\text{dote}&{\text{if } \text{dote} \geq 0;}\\\text{dote}-146096&{\text{otherwise.}}\end{cases}}{146097} \Biggr \rfloor$$

$$\text{doc} = \text{dote} - \text{coe} \times 146097$$

$$\text{yoc} = \biggl \lfloor \frac{\text{doc} - \lfloor \frac{\text{doc}}{1460} \rfloor + \lfloor \frac{\text{doc}}{36524} \rfloor - \lfloor \frac{\text{doc}}{146096} \rfloor}{365} \biggr \rfloor$$

$$\text{year} = \text{yoc} + \text{coe} \times 400$$

$$\text{doty} = \text{doc} - \text{yoc} \times 365 - \lfloor \frac{\text{yoc}}{4} \rfloor + \lfloor \frac{\text{yoc}}{100} \rfloor$$
:::

Dates generated by the Dec date equations are guaranteed to be in the standard [year]{.yellow}+[day]{.cyan} format. Therefore, we can standardize Dec dates by performing a [round-trip](https://en.wikipedia.org/wiki/Round-trip_format_conversion#:~:text=converting%20from%20any%20data%20representation%20and%20back%20again) date-to-dote-to-date conversion using the Dec dote and date equations consecutively. This allows Dec to handle Dec dates with a non-integer [year]{.yellow} and a [day]{.cyan} outside the typical range of [0]{.cyan} &le; [day]{.cyan} &le; [365]{.cyan}.

# Yote

A dote is essentially a Dec date with a [year]{.yellow} that is always equal to [0]{.yellow} and a [day]{.cyan} that is unbounded. Similarly, a Dec year of the era (yote) is basically a Dec with a non-integer [year]{.yellow} and a [day]{.cyan} permanently set to [0]{.cyan}. Both dotes and yotes allow us to represent a date as a single number and obtain the difference between two dates, either in days ([d~M~]{.cyan} - [d~S~]{.cyan}) or years ([y~M~]{.yellow} - [y~S~]{.yellow}).

Compared to dotes, yotes are easier to turn into Dec dates. We can convert dates to yotes and vice versa with the Dec yote equation: [y]{.yellow} = &LeftFloor;[y]{.yellow}&RightFloor; + [d]{.cyan} &div; [n]{.orange}. In the Dec yote equation, [y]{.yellow} is the yote, &LeftFloor;[y]{.yellow}&RightFloor; + [d]{.cyan} is the Dec date, &LeftFloor;[y]{.yellow}&RightFloor; is the year, [d]{.cyan} is the doy, and [n]{.orange} is the number of days in Year &LeftFloor;[y]{.yellow}&RightFloor;. The current yote equation values are [\${fullfracYear}]{.yellow} = [\${decoYear}]{.yellow} + [\${decoDoty}]{.cyan} &div; [\${nDaysInYear}]{.orange}.

Dec dates do not include [n]{.orange}, because it is not needed to specify a date, remains constant for 366, 1095, or 2920 days, has only 2 possible values: 366 if &LeftFloor;[y]{.yellow}&RightFloor;+1 is a [Gregorian calendar](https://en.wikipedia.org/wiki/Gregorian_calendar#:~:text=the%20calendar%20used%20in%20most%20parts%20of%20the%20world) [leap year](https://en.wikipedia.org/wiki/Leap_year#:~:text=a%20calendar%20year%20that%20contains%20an%20additional%20day) and 365 if &LeftFloor;[y]{.yellow}&RightFloor;+1 is a Gregorian calendar [common year](https://en.wikipedia.org/wiki/Common_year#:~:text=a%20calendar%20year%20with%20365%20days), and can be determined by applying the Gregorian calendar [leap year rule](https://en.wikipedia.org/wiki/Leap_year#:~:text=Every%20year%20that%20is%20exactly%20divisible%20by%20four%20is%20a%20leap%20year%2C%20except%20for%20years%20that%20are%20exactly%20divisible%20by%20100%2C%20but%20these%20centurial%20years%20are%20leap%20years%20if%20they%20are%20exactly%20divisible%20by%20400) to &LeftFloor;[y]{.yellow}&RightFloor;+1, as shown in the Dec year length equation:

$$\text{n}=\begin{cases}
  366&{\begin{align}\text{if } (\lfloor \text{y}\rfloor+1)\text{ mod }\ \ \ \ 4=0\\
  \href{https://en.wikipedia.org/wiki/Logical_conjunction}{\land}(\lfloor \text{y}\rfloor+1)\text{ mod }100\neq0\\
  \href{https://en.wikipedia.org/wiki/Logical_disjunction}{\lor}(\lfloor \text{y}\rfloor+1)\text{ mod }400=0\end{align}}\\\\
  365&{\text{otherwise.}}\end{cases}$$

Apart from its role in the Dec date and doy equations, [n]{.orange} is needed to convert between [year]{.yellow}+[day]{.cyan} and [year]{.yellow}-[day]{.pink} Dec dates. The [year]{.yellow}-[day]{.pink} version of the Dec yote equation is &LeftFloor;[y]{.yellow}&RightFloor;+1+([d]{.cyan}-[n]{.orange})&div;[n]{.orange}=[y]{.yellow}. In essence, [d]{.cyan}-[n]{.orange} is a ["T-minus" countdown](https://en.wikipedia.org/wiki/Countdown#:~:text=backward%20counting%20to%20indicate%20the%20time%20remaining%20before%20an%20event) of the days until the start of Year &LeftFloor;[y]{.yellow}&RightFloor;+1. The current [year]{.yellow}-[day]{.pink} date, [\${nextYear}]{.yellow}-[\${Tminus}]{.pink}, tells us that Year [\${nextYear}]{.yellow} will begin in [\${Tminus}]{.pink} days.

The difference between [d]{.cyan} and [d]{.cyan}-[n]{.orange} can also be explained in terms of computer programming. If we think of years as [arrays](https://en.wikipedia.org/wiki/Array_(data_structure)#Element_identifier_and_addressing_formulas:~:text=a%20data%20structure%20consisting%20of%20a%20collection%20of%20elements%20(values%20or%20variables)%2C%20of%20same%20memory%20size%2C%20each%20identified%20by%20at%20least%20one%20array%20index), [d]{.cyan} and [d]{.cyan}-[n]{.orange} are like array [indexes](https://en.wikipedia.org/wiki/Array_(data_structure)#Element_identifier_and_addressing_formulas:~:text=individual%20objects%20are%20selected%20by%20an%20index) that can be used to identify array elements or combine them into groups via [slicing](https://en.wikipedia.org/wiki/Array_slicing#:~:text=an%20operation%20that%20extracts%20a%20subset%20of%20elements%20from%20an%20array). In this analogy, [n]{.orange} is the number of elements in the array, [d]{.cyan} is a [positive index](https://en.wikipedia.org/wiki/Zero-based_numbering#:~:text=a%20way%20of%20numbering%20in%20which%20the%20initial%20element%20of%20a%20sequence%20is%20assigned%20the%20index%C2%A00), and [d]{.cyan}-[n]{.orange} is a [negative index](https://en.wikipedia.org/wiki/Array_slicing#:~:text=specify%20an%20offset%20from%20the%20end%20of%20the%20array).

The yote equation can be rearranged into the Dec doy equation, [d]{.cyan} = &LeftFloor;[y]{.yellow} [mod](https://en.wikipedia.org/wiki/Modulo#:~:text=returns%20the%20remainder) 1 &times; [n]{.orange}&RightFloor;, where [y]{.yellow} [mod](https://en.wikipedia.org/wiki/Modulo#:~:text=returns%20the%20remainder) 1 is the [decimal part](https://en.wikipedia.org/wiki/Fractional_part#:~:text=the%20excess%20beyond%20that%20number%27s%20integer%20part) of [y]{.yellow}. The current doy equation values are [\${decoDoty}]{.cyan} = &LeftFloor;[\${mod1FracYear}]{.yellow} &times; [\${nDaysInYear}]{.orange}&RightFloor;. We can refer to a doy without a year as a floating date and a [year]{.yellow}+[day]{.cyan} date as a fixed date. Unlike other types of dates, floating dates do not specify the year and thus apply to any year.

Fixed dates are essentially [unsimplified](https://en.wikipedia.org/wiki/Simplification#:~:text=the%20process%20of%20replacing%20a%20mathematical%20expression%20by%20an%20equivalent%20one%2C%20that%20is%20simpler) math expressions. Dec uses unsimplified math expressions to display information about a date, such as its doy [d]{.cyan} or POSIX dow [w]{.azul}. Essentially, you can modify a Dec date to show whatever numbersüî¢you want. All it takes is a little bit of arithmetic! This incredible versatility is possible thanks to the mathematical basis of Dec date notation.

# Week

Even though Dec uses deks instead of weeks, Dec dates can be modified to include [POSIX](https://en.wikipedia.org/wiki/POSIX#:~:text=a%20family%20of%20standards%20specified%20by%20the%20IEEE%20Computer%20Society%20for%20maintaining%20compatibility%20between%20operating%20systems) [Sunday-based weekday numbers](https://pubs.opengroup.org/onlinepubs/007904875/utilities/date.html#:~:text=weekday%20as%20a%20decimal%20number%20%5B0%2C6%5D%20(0%3Dsunday)). To convert the current Dec date, [\${decoYear}]{.yellow}+[\${decoDoty}]{.cyan}, into the current Dec dow date, [\${decoYear}]{.yellow}\${dotw0sign}[\${dotw0doty}]{.cyan}+[\${dotw}]{.azul}, we split the current doy, [\${decoDoty}]{.cyan}, into the doy of the first day of the current week, [\${dotw0doty}]{.cyan}, and the current POSIX weekday number: [\${dotw}]{.azul}.

Instead of the doy [d]{.cyan}, Dec dow dates display [d]{.cyan}-[w]{.azul}+[w]{.azul}, where [d]{.cyan}-[w]{.azul} is the first doy of the current week and [w]{.azul} is the dow number associated with the doy [d]{.cyan}. We evaluate the subtraction, but leave the addition unsimplified so we can see [w]{.azul}. Dec dow dates provide all of the information needed to identify specific dates and coordinate schedules based on deks or weeks.

Dec dow dates can be further modified to include [POSIX week numbers](https://pubs.opengroup.org/onlinepubs/007904875/utilities/date.html#:~:text=week%20of%20the%20year%20(sunday%20as%20the%20first%20day%20of%20the%20week)%20as%20a%20decimal%20number%20%5B00%2C53%5D.%20all%20days%20in%20a%20new%20year%20preceding%20the%20first%20sunday%20shall%20be%20considered%20to%20be%20in%20week%200.). The current week number, \${week}, is the result of adding the middle number in the Dec dow date, [\${dotw0doty}]{.cyan}, to the Day 0 dow number, [\${doty0dotw}]{.azul}, and then floor dividing by 7. The current Dec floating week date, 7&times;[\${week}]{.wheat}+[\${dotw}]{.azul}, is equal to the sum of the current doy and the Day 0 dow number: 7&times;[\${week}]{.wheat}+[\${dotw}]{.azul}=[\${decoDoty}]{.cyan}+[\${doty0dotw}]{.azul}.


Dec week dates turn [d]{.cyan}-[w]{.azul} into 7&times;[W]{.wheat}-[w~0~]{.azul}, where [W]{.wheat} is the week number and [w~0~]{.azul} is the dow number on Day 0. In this case, the subtraction is omitted, because [w~0~]{.azul} is not necessary to identify a date and can be calculated from a given [y]{.yellow} by flooring it, turning it into a dote, and passing it into the dow equation. POSIX week numbers may be useful for [week-based accounting](https://en.wikipedia.org/wiki/Accounting_period#52%E2%80%9353-week_fiscal_year:~:text=used%20by%20companies%20that%20desire%20that%20their%20fiscal%20year%20always%20end%20on%20the%20same%20day%20of%20the%20week)üßæ.

Following the Dec week date pattern, we can base Dec dates on any fixed-length calendar unit, including the 20-day [dudek](https://en.wiktionary.org/wiki/dudek#Esperanto:~:text=dudek-,twenty,-Polish%5Bedit), 30-day [tridek](https://en.wiktionary.org/wiki/tridek#Esperanto:~:text=tridek-,thirty,-Categories%3A), 40-day [kvardek](https://en.wiktionary.org/wiki/kvardek#Esperanto:~:text=kvardek-,forty,-Categories%3A), or 73-day [sepdektri](https://en.wiktionary.org/wiki/sepdek_tri#Esperanto:~:text=sepdek%20tri-,seventy%2Dthree,-Categories%3A). No other calendar unit can be as convenient as the 10-day [dek](https://en.wiktionary.org/wiki/dek#Esperanto:~:text=dek-,ten%20(10),-Derived%20terms%5B), because our [decimal numeral system](https://en.wikipedia.org/wiki/Decimal#:~:text=system%20for%20denoting%20integer%20and%20non%2Dinteger%20numbers) allows us to naturally combine a dek, [\${decoDoty.slice(0, 2)}]{.cyan}, and dotd, [\${decoDoty[2]}]{.cyan}, into a doty: [\${decoDoty}]{.cyan}.

# Month

Dec dates can also be modified to display Dec month numbers and [POSIX day-of-month (dom) numbers](https://pubs.opengroup.org/onlinepubs/007904875/utilities/date.html#:~:text=day%20of%20the%20month%20as%20a%20decimal%20number%20%5B01%2C31%5D). The current Dec dom date is [\${decoYear}]{.yellow}+[\${monthNumber}]{.cyan}+[\${dotm}]{.magenta}. Dec dom dates represent each month with the last doy of the previous month because POSIX dom numbers are one-based. For [zero-based](https://en.wikipedia.org/wiki/Zero-based_numbering#:~:text=a%20way%20of%20numbering%20in%20which%20the%20initial%20element%20of%20a%20sequence%20is%20assigned%20the%20index%C2%A00) dom numbers, we represent each month with its first doy: [\${decoYear}]{.yellow}+[\${monthNumber0}]{.cyan}+[\${dotm0}]{.magenta}.

Dec dom dates replace the doy [d]{.cyan} from Dec dates with [d]{.cyan}-[m]{.magenta}+[m]{.magenta}. We evaluate the subtraction to get [d]{.cyan}-[m]{.magenta}, the Dec month number, but not the addition, so we can see [m]{.magenta}, the dom number. If we combine the dom and dow patterns above, we can create hybrid Dec dates: [\${decoYear}]{.yellow}+[\${monthNumber - dotw}]{.cyan}+[\${dotm}]{.magenta}+[\${dotw}]{.azul}, where [\${monthNumber - dotw}]{.cyan} is [d]{.cyan}-[m]{.magenta}-[w]{.azul}, the doy of the last Sunday before the beginning of the month.

We can obtain Dec month numbers using only a pair of handsü§≤by counting index‚òùÔ∏èand ringüíçfingers as 30 days and other fingers as 31 days. For zero-based dom numbers,
we start counting from 0. For one-based dom numbers, we start counting from -1, as shown in the image below. To spread 12 months across 10 fingers, the first and last fingers each represent 2 months.

{{< include _finger.qmd >}}

The combination of a Dec date and a Dec time is a called a snap. A Dec date is essentially a Dec snap that has been [truncated](https://en.wikipedia.org/wiki/Truncation#:~:text=limiting%20the%20number%20of%20digits%20right%20of%20the%20decimal%20point) until the time is no longer specified. Truncation of both positive and negative doy values in Dec snaps can be accomplished with the [floor function](https://en.wikipedia.org/wiki/Floor_and_ceiling_functions#:~:text=the%20greatest%20integer%20less%20than%20or%20equal%20to%20x): &LeftFloor;[d]{.cyan}&RightFloor;. Unlike Pandas [string](https://en.wikipedia.org/wiki/String_(computer_science)#:~:text=a%20sequence%20of%20characters) indexes, Dec snaps cannot be shortened to a [year and a month](https://pandas.pydata.org/docs/user_guide/timeseries.html#partial-string-indexing:~:text=the%20year%20or-,year%20and%20month,-as%20strings%3A).

The subsequent articles on my site build on this article to further describe Dec [times](/dec/time), [snaps](/dec/span), and [spans](/dec/span). A basic understanding of the Dec [year]{.yellow}+[day]{.cyan} date format is enough to understand the examples in the [filter](/quarto/filter) and [script](/quarto/script) articles in the [Quarto section](/quarto) of my site, but it might be helpful to read my [Dec time article](/dec/time) before moving on to my Quarto [include article](/quarto/include).

Thank you for your interest in Dec. You will find citation information for this article below. Please note that the original source of the algorithms underlying the conversion of Dec dates and dotes is [Howard Hinnant](https://howardhinnant.github.io). [2021+184]{.underline .tool data-bs-toggle="tooltip" data-bs-title="2021-09-01"}. ‚Äú`chrono`-Compatible Low-Level Date Algorithms.‚Äù [\${decoYear}]{.yellow}+[\${decoDoty}]{.cyan}. <https://howardhinnant.github.io/date_algorithms.html>.

```{ojs}
//| echo: false
//| output: false
unix = {
  while(true) {
    yield Date.now();
  }
}
// http://howardhinnant.github.io/date_algorithms.html#civil_from_days
function unix2dote(unix, zone, offset = 719468) {
  return [(unix ?? Date.now()) / 86400000 + (
    zone = zone ?? -Math.round(
      (new Date).getTimezoneOffset() / 144)
    ) / 10 + offset, zone]
}
function dote2date(dote, zone = 0) {
  const cote = Math.floor((
      dote >= 0 ? dote
      : dote - 146096
    ) / 146097),
  dotc = dote - cote * 146097,
  yotc = Math.floor((dotc
    - Math.floor(dotc / 1460)
    + Math.floor(dotc / 36524)
    - Math.floor(dotc / 146096)
  ) / 365);
  return [
    yotc + cote * 400,
    dotc - (yotc * 365
      + Math.floor(yotc / 4)
      - Math.floor(yotc / 100)
  ), zone]}
function doty2deco0(year = 1969, doty = 306, zone = 0) {
  return `${year.toString().padStart(4, "0")}+${Math.floor(doty).toString().padStart(3, "0")}${String(doty % 1 * 10).slice(0, 6)}-${zone}`
}
function dotw2diff(x, y) {
  return (x - y + 7) % 7;
}
dz = unix2dote(unix)
ydz = dote2date(...dz)
deco = doty2deco0(...ydz)
function year2leap(year = 1970) {
  return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}
function dote2dotw(d = 719468) {
  return d >= -3 ? (d + 3) % 7 : (d + 4) % 7 + 6
}
decoYear = deco.slice(0, 4)
nextYear = parseInt(decoYear) + 1
decoDoty = deco.slice(5, 8)
xmasDote = date2dote(ydz[0], 299)[0]
xmasDotw = dote2dotw(xmasDote)
dotw = Math.floor(dote2dotw(dz[0]))
day266dotw = dote2dotw(date2dote(ydz[0], 266)[0])
day266dotwDiff = dotw2diff(4, day266dotw)
week = Math.floor((ydz[1] + doty0dotw) / 7)
dotm = doty2dotm(Math.floor(ydz[1]))
dotm0 = String(dotm - 1).padStart(2, "0")
dotm1 = dotm.toString().padStart(2, "0")
monthNumber = Math.floor(ydz[1] - dotm)
monthNumber0 = String(monthNumber + 1).padStart(3, "0")
monthNumber1 = monthNumber.toString().padStart(3, "0")
dotw0doty = Math.floor(ydz[1]) - dotw
doty0dote = date2dote(ydz[0], 0, ydz[2])
doty0dotw = dote2dotw(...doty0dote)
dotw0sign = dotw0doty < 0 ? "-" : "+"
nDaysInYear = 365 + year2leap(ydz[0] + 1)
Tminus = nDaysInYear - decoDoty
fracYear = ydz[0] + ydz[1] / nDaysInYear
fullfracYear = (fracYear).toFixed(4)
mod1FracYear = (fracYear % 1).toFixed(4)
months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
monthNums = ["305", "336", "", "31", "61", "92", "122", "153", "184", "214", "245", "275"];
today = new Date()
monthName = today.toLocaleString('default', { month: 'long' });
monthNumJS = today.getMonth();
currMonth = monthNums[monthNumJS]
nextMonth = monthNums[(monthNumJS + 1) % 12]
dekStart = Math.floor(decoDoty / 10) * 10
diff = parseInt(currMonth || 0) - parseInt(nextMonth || nDaysInYear)
  //currMonth === "" ? 0 : parseInt(currMonth) - nextMonth === "" ? nDaysInYear : parseInt(nextMonth)
// https://observablehq.com/@juang1744/transform-input/1
transformInput = function(target, {bind: source, transform = identity, involutory = false, invert = involutory ? transform : inverse(transform)} = {}){
  if (source === undefined) {
    source = target;
    target = html`<div>${source}</div>`;
  }
  function sourceInputHandler() {
    target.removeEventListener("input", targetInputHandler);
    setTransform(target).to(transform(source.value)).andDispatchEvent();
    target.addEventListener("input", targetInputHandler);
  }
  function targetInputHandler() {
    source.removeEventListener("input", sourceInputHandler);
    setTransform(source).to(invert(target.value)).andDispatchEvent();
    source.addEventListener("input", sourceInputHandler);
  }
  source.addEventListener("input", sourceInputHandler);
  target.addEventListener("input", targetInputHandler);
  invalidation.then(() => {
    source.removeEventListener("input", sourceInputHandler);
    target.removeEventListener("input", targetInputHandler);
  });
  sourceInputHandler();
  return target;
}
setTransform = (input) => ({to: (value) => (input.value = value, {andDispatchEvent: (event = new Event("input")) => input.dispatchEvent(event)})});
function inverse(f) {
  switch (f) {
    case identity:  return identity;
    case Math.sqrt: return square;
    case Math.log:  return Math.exp;
    case Math.exp:  return Math.log;
    default:        return (x => solve(f, x, x));
  }
  function solve(f, y, x = 0) {
    const dx = 1e-6;
    let steps = 100, deltax, fx, dfx;
    do {
      fx = f(x)
      dfx = (f(x + dx) - fx) || dx;
      deltax = dx * (fx - y)/dfx
      x -= deltax;
    } while (Math.abs(deltax) > dx && --steps > 0);
    return steps === 0 ? NaN : x;
  }
function square(x) {
    return x * x;
  }
}
function identity(x) {
  return x;
}
function doty2month(doty = 0) {
    const m = Math.floor((5 * doty + 2) / 153);
    return Math.floor(m < 10 ? m + 3 : m - 9);
}
function month2doty(month = 1) {
    return Math.floor(
        (153 * (month > 2 ? month - 3 : month + 9) + 2) / 5
)}
function doty2dotm(doty = 0) {
    const m = Math.floor((5 * doty + 2) / 153);
    return doty - Math.floor((153 * m + 2) / 5) + 1;
}
numbers = Array.from({length: 366}, (_, i) => i)
set(viewof dotyInput, leapscrub[0])
// https://observablehq.com/@observablehq/synchronized-inputs
function set(input, value) {
  input.value = value;
  input.dispatchEvent(new Event("input", {bubbles: true}));
}
// https://observablehq.com/@mbostock/scrubber
function Scrubber(values, {
  format = value => value,
  initial = 0,
  direction = 1,
  delay = null,
  autoplay = true,
  loop = true,
  loopDelay = null,
  alternate = false,
  inputStyle = ""
} = {}) {
  values = Array.from(values);
  const form = html`<form style="font: 18px var(--monospace); font-variant-numeric: tabular-nums; display: flex; height: 33px; align-items: center;">
  <button name=b type=button style="margin-right: 0.4em; width: 5em;"></button>
  <label style="display: flex; align-items: center;">
    <input name=i type=range min=0 max=${values.length - 1} value=${initial} step=1 style=${inputStyle}>
    <output name=o style="margin-left: 0.4em;"></output>
  </label>
</form>`;
  let frame = null;
  let timer = null;
  let interval = null;
  function start() {
    form.b.textContent = "Stop";
    if (delay === null) frame = requestAnimationFrame(tick);
    else interval = setInterval(tick, delay);
  }
  function stop() {
    form.b.textContent = "Play";
    if (frame !== null) cancelAnimationFrame(frame), frame = null;
    if (timer !== null) clearTimeout(timer), timer = null;
    if (interval !== null) clearInterval(interval), interval = null;
  }
  function running() {
    return frame !== null || timer !== null || interval !== null;
  }
  function tick() {
    if (form.i.valueAsNumber === (direction > 0 ? values.length - 1 : direction < 0 ? 0 : NaN)) {
      if (!loop) return stop();
      if (alternate) direction = -direction;
      if (loopDelay !== null) {
        if (frame !== null) cancelAnimationFrame(frame), frame = null;
        if (interval !== null) clearInterval(interval), interval = null;
        timer = setTimeout(() => (step(), start()), loopDelay);
        return;
      }
    }
    if (delay === null) frame = requestAnimationFrame(tick);
    step();
  }
  function step() {
    form.i.valueAsNumber = (form.i.valueAsNumber + direction + values.length) % values.length;
    form.i.dispatchEvent(new CustomEvent("input", {bubbles: true}));
  }
  form.i.oninput = event => {
    if (event && event.isTrusted && running()) stop();
    form.value = values[form.i.valueAsNumber];
    form.o.value = format(form.value, form.i.valueAsNumber, values);
  };
  form.b.onclick = () => {
    if (running()) return stop();
    direction = alternate && form.i.valueAsNumber === values.length - 1 ? -1 : 1;
    form.i.valueAsNumber = (form.i.valueAsNumber + direction) % values.length;
    form.i.dispatchEvent(new CustomEvent("input", {bubbles: true}));
    start();
  };
  form.i.oninput();
  if (autoplay) start();
  else stop();
  Inputs.disposal(form).then(stop);
  return form;
}
calYear = !leapInput && dotwInput == "Monday" ? 6 : !leapInput && dotwInput == "Tuesday" ? 7 : !leapInput && dotwInput == "Wednesday" ? 2 : !leapInput && dotwInput == "Thursday" ? 3 : !leapInput && dotwInput == "Friday" ? 9 : !leapInput && dotwInput == "Saturday" ? 10 : !leapInput && dotwInput == "Sunday" ? 11 : leapInput && dotwInput == "Monday" ? 12 : leapInput && dotwInput == "Tuesday" ? 24 : leapInput && dotwInput == "Wednesday" ? 8 : leapInput && dotwInput == "Thursday" ? 20 : leapInput && dotwInput == "Friday" ? 4 : leapInput && dotwInput == "Saturday" ? 16 : leapInput && dotwInput == "Sunday" ? 28 : 0;
datesCal = d3.utcDays(new Date(calYear, 0, 0), new Date(calYear, 12, 0));
function unix2doty(unix) {
  const dote = (
    unix ?? Date.now()
  ) / 86400000 + 719468,
    cote = Math.floor((
      dote >= 0 ? dote
      : dote - 146096
    ) / 146097),
  dotc = dote - cote * 146097,
  yotc = Math.floor((dotc
    - Math.floor(dotc / 1460)
    + Math.floor(dotc / 36524)
    - Math.floor(dotc / 146096)
  ) / 365);
  return dotc - (yotc * 365
      + Math.floor(yotc / 4)
      - Math.floor(yotc / 100)
  )}
function date2dote(year = 1969, doty = 306, zone = 0) {
    const cote = Math.floor((year >= 0 ? year : year - 399) / 400),
      yote = year - cote * 400;
    return [cote * 146097 + yote * 365 + Math.floor(yote / 4) - Math.floor(yote / 100) + doty, zone]
}
function doty2deco(yearDoty = [1969, 306], zone = 0) {
    const yd = dote2date(...date2dote(yearDoty[0], Math.floor(yearDoty[1]), zone));
    return `${yd[0].toString().padStart(4, "0")}+${yd[1].toString().padStart(3, "0")}${
        yearDoty[1].toString().includes(".") ? "." + (
            (yearDoty[1] > 0) ? (yearDoty[1] - zone).toString().split(".").pop()
            : [...(yearDoty[1] - zone).toString().split(".").pop()].map(
                (e, i, a) => (i + 1 === a.length) ? 10 - e : 9 - e
            ).join("")
        ) : ""
    }`
}
function deco2doty(timestamp = "1969+306.00000Z") {
    const arr = timestamp.toString().split(/(?=[+-]|[a-zA-Z])/, 3);
    switch (arr.length) {
        case 1: return [unix2doty(Date.now())[0], parseFloat(arr[0]), 0];
        case 2: return (/^[a-zA-Z]+$/.test(arr[1]))
            ? [unix2doty(Date.now())[0], parseFloat(arr[0]), zone2hour(arr[1]) / 24]
            : [parseFloat(arr[0]), parseFloat(arr[1]), 0];
    };
    return [parseFloat(arr[0]), parseFloat(arr[1]), /^[a-zA-Z]+$/.test(arr[2])
        ? zone2hour(arr[2]) / 24
        : parseFloat(arr[2].replace(/([+-])/, "$1\."))];
}
function zone2hour(zone = "Z") {
    return (zone = zone.toUpperCase()) == "Z" ? 0
        : zone > "@" && zone < "J" ? zone.charCodeAt() - 64
        : zone > "J" && zone < "N" ? zone.charCodeAt() - 65
        : zone < "Z" && zone > "M" ? -(zone.charCodeAt() - 77)
        : zone;
}
function doty2unix(year = 1969, doty = 306, zone = 0) {
    return (date2dote(year, doty, zone) - 719468) * 86400000;
}
function doty2isoc(yd) {
    return new Date(doty2unix(...yd))
}
function doty2greg(doty = 306) {
    const m = Math.floor((5 * doty + 2) / 153);
    return [
      Math.floor(m < 10 ? m + 3 : m - 9),
      Math.floor(doty - (153 * m + 2) / 5 + 2)
    ];
}
function greg2doty(month = 1, day = 1) {
    return Math.floor(
        (153 * (month > 2 ? month - 3 : month + 9) + 2) / 5 + day - 1
)}
function greg2year(year = 1970, month = 1) { return year - (month < 3) }
function isoc2doty(isoc) {
  return [greg2year(isoc.getFullYear(), isoc.getUTCMonth() + 1), greg2doty(isoc.getUTCMonth() + 1, isoc.getUTCDate())];
}
leapInput = leapscrub[1]
function addN(d) { return d + 365 + leapInput }
function subN(d) { return d - 365 - leapInput }
dates = d3.utcDays(new Date(1999, 2, 0), new Date(2000, 1, 28 + leapInput));
```

```{=html}
<style>
h6.relative.anchored {
  margin-top: -25px;
  margin-bottom: -2px;
}
<!-- .calplot { -->
<!--   margin-top: -15px; -->
<!--   margin-bottom: -15px; -->
<!-- } -->
#decalendar > g.cluster-label {
  transform: translate(305px, 50px) !important;
}
span.cal-swatch {
  font-size: 14px !important;
}
form.oi-3a86ea-checkbox {
  max-width: 700px;
}
div.cell:has(form.oi-3a86ea-toggle) {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
}
div.observablehq > div:has(form.oi-3a86ea-toggle) {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
}
form.oi-3a86ea-toggle {
  max-width: 100% !important;
  --label-width: 100px;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
}
form.oi-3a86ea {
  --input-width: 200px;
  padding-right: 9px;
}
form.oi-3a86ea-toggle > label {
  width: 75px;
}
input.oi-3a86ea-input[type="checkbox"] {
  margin: 6px 0px 0px 0px;
}
div > form > label {
  --label-width: 140px;
}
input[type="radio"], input[type="checkbox"] {
  margin: 2px 0px 0px 0px;
}
p:has(.radiotitle) {
  margin-top: -8px !important;
  margin-bottom: -4px;
  text-align: center;
}
svg#finger {
  max-width: 760px;
}
h4.anchored {
  margin: 8px 0px 8px 0px;
}
</style>
```
