---
title: Date
image: /asset/deidek.svg
draft: true
citation:
  url: 'https://maptv.github.io/dec/date'
toc-depth: 4
format:
  html:
    include-after-body:
      - ../../asset/cite.html
      - ../../asset/style.html
      - ../../asset/stamp.html
      - ../../asset/tooltip.html
  commonmark: default
format-links:
  - html
  - text: JavaScript Jupyter
    href: index.js.ipynb
    icon: journal-richtext
  - text: JavaScript Quarto
    href: index.js.qmd
    icon: journal-code
  - text: JavaScript Script
    href: index.js
    icon: filetype-js
  - text: JavaScript Markdown
    href: index.js.md
    icon: markdown
#  - text: Julia Jupyter
#    href: index.jl.ipynb
#    icon: journal-richtext
#  - text: Julia Quarto
#    href: index.jl.qmd
#    icon: journal-code
#  - text: Julia Script
#    href: index.jl
#    icon: file-earmark
#  - text: Julia Markdown
#    href: index.jl.md
#    icon: markdown
  - text: Lua Jupyter
    href: index.lua.ipynb
    icon: journal-richtext
  - text: Lua Quarto
    href: index.lua.qmd
    icon: journal-code
  - text: Lua Script
    href: index.lua
    icon: moon
  - text: Lua Markdown
    href: index.lua.md
    icon: markdown
  - text: Python Jupyter
    href: index.py.ipynb
    icon: journal-richtext
  - text: Python Quarto
    href: index.py.qmd
    icon: journal-code
  - text: Python Script
    href: index.py
    icon: filetype-py
  - text: Python Markdown
    href: index.py.md
    icon: markdown
  - text: R Jupyter
    href: index.r.ipynb
    icon: journal-richtext
  - text: R Quarto
    href: index.r.qmd
    icon: journal-code
  - text: R Script
    href: index.r
    icon: r-circle
  - text: R Markdown
    href: index.r.md
    icon: markdown
  - text: Shell Jupyter
    href: index.sh.ipynb
    icon: journal-richtext
  - text: Shell Quarto
    href: index.sh.qmd
    icon: journal-code
  - text: Shell Script
    href: index.sh
    icon: filetype-sh
  - text: Shell Markdown
    href: index.sh.md
    icon: markdown
notebook-links: false
filters:
  - ../../asset/date.lua
  - include-code-files
---

My website serves as a demonstration of both the [Quarto](https://quarto.org) publishing system and the [Dec](/dec) measurement system. I use several clever hacks to get Quarto to display all of the dates on my website in the Dec `year+day` format. Knowing the basics of Dec dates will help you to understand the Quarto [filter](https://quarto.org/docs/extensions/filters.html), [render script](https://quarto.org/docs/projects/scripts.html#pre-and-post-render), and [include file](https://quarto.org/docs/output-formats/html-basics.html#includes) examples in my [Quarto article](/software/quarto).

### Conversion

Even though it does not use months or weeks, Dec supports [round-trip conversion](https://en.wikipedia.org/wiki/Round-trip_format_conversion#:~:text=converting%20from%20any%20data%20representation%20and%20back%20again) to all three [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#:~:text=an%20international%20standard%20covering%20the%20worldwide%20exchange%20and%20communication%20of%20date%20and%20time%2Drelated%20data) date formats, including ISO [month](https://en.wikipedia.org/wiki/ISO_8601#Calendar_dates) and [week](https://en.wikipedia.org/wiki/ISO_week_date#:~:text=a%20leap%20week%20calendar%20system) dates. Dec dates can be directly converted into ISO month and [ordinal](https://en.wikipedia.org/wiki/ISO_8601#Ordinal_dates:~:text=an%20ordinal%20format%20for%20the%20multiples%20of%20a%20day%20elapsed%20since%20the%20start%20of%20year) dates, but conversion to ISO week dates requires the intermediate step of turning a Dec date into a Dec day of the [era](https://en.wikipedia.org/wiki/Calendar_era#:~:text=the%20period%20of%20time%20elapsed%20since%20one%20epoch%20of%20a%20calendar) (dote).

It is easy to convert a dote into a day of the week (dotw), [UNIX](https://en.wikipedia.org/wiki/Unix#:~:text=a%20family%20of%20multitasking%2C%20multi%2Duser%20computer%20operating%20systems) [timestamp](https://en.wikipedia.org/wiki/Unix_time#:~:text=the%20number%20of%20non%2Dleap%20seconds%20that%20have%20elapsed%20since%2000%3A00%3A00%20UTC%20on%201%C2%A0January%201970), [Julian date](https://en.wikipedia.org/wiki/Julian_day#:~:text=the%20Julian%20day%20number%20plus%20the%20fraction%20of%20a%20day%20since%20the%20preceding%20noon%20in%20Universal%20Time), or [Rata Die](https://en.wikipedia.org/wiki/Rata_Die#:~:text=a%20system%20for%20assigning%20numbers%20to%20calendar%20days) [fractional day](https://en.wikipedia.org/wiki/Rata_Die#Fractional_days:~:text=a%20continuously%2Dincreasing%20fractional%20number).
The [Mermaid](https://mermaid.js.org) flowchart below shows how the dote `741343` can be converted into many different formats. You can jump to the section in this article that focuses on a given format by clicking on its corresponding rectangle in the flowchart.


```{mermaid}
flowchart LR
   A[UNIX\n1890000000]<-->B[dote\n741343]
   C[Rata Die\n741038]<-->B
   D[Julian date\n2462462.5]<-->B
   subgraph dec[Dec]
   B<-->E[date\n2029+266]
   end
   E<-->F[ordinal date\n2029-326]
   E<-->G[month date\n2029-11-22]
   H((dotw\n4))-->B
   H-->I[week date\n2029-W47-4]
   subgraph iso[ISO 8601]
   F
   G
   I
   end
   B---H
   %% B-->H[HH:MM:SS\n00:00:00]
   %% C-->H
   linkStyle 8 stroke-width:0px;
   style dec y:80px,x:135px,width:270px,height:160px;
   style H stroke:none,fill:none;
   click A "#unix"
   click B "#dote"
   click C "#rd"
   click D "#jd"
   click E "#date"
   click F "#ordinal"
   click G "#month"
   click H "#dotw"
   click I "#week"
```

#### UNIX

UNIX time is the number of seconds since the [UNIX epoch](https://en.wikipedia.org/wiki/Epoch_(computing)#:~:text=Thursday%201%20January%201970%2000%3A00%3A00%20UT%2C%20a%20point%20in%20time%20known%20as%20the%20Unix%20epoch). Dec uses days instead of seconds and has a different [epoch](https://en.wikipedia.org/wiki/Epoch_(computing)#:~:text=a%20fixed%20date%20and%20time%20used%20as%20a%20reference). To work with UNIX timestamps, Dec converts them into days of the era (dotes) by first turning seconds into days and then shifting the epoch to [`0000+000`]{.underline .blue data-bs-toggle="tooltip" data-bs-title="March 1, 1 BCE"}. The reverse conversion first shifts the epoch to [`1969+306`]{.underline .blue data-bs-toggle="tooltip" data-bs-title="January 1, 1970 CE"} and then turns days into seconds.

$$dote = unix \div 86400 + 719468$$

$$unix = (dote - 719468) \times 86400$$

#### Rata Die

Rata Die (RD) fractional days are almost identical to dotes. The only difference is that the RD epoch, [`0000+305`]{.underline .blue data-bs-toggle="tooltip" data-bs-title="December 31, 1 BCE"}, is 305 days after the Dec epoch, [`0000+000`]{.underline .blue data-bs-toggle="tooltip" data-bs-title="March 1, 1 BCE"}. Therefore, conversion between dotes and RD fractional days is as simple as adding or subtracting 305. For more information on RD fractional days, take a look at the book entitled "[Calendrical Calculations](https://en.wikipedia.org/wiki/Calendrical_Calculations#:~:text=a%20book%20on%20calendar%20systems%20and%20algorithms%20for%20computers%20to%20convert%20between%20them)".

$$rd = dote - 305$$

$$dote = rd + 305$$

#### Julian date

A Julian date is a continuous count of days since [`-4713+268.5`]{.underline .blue data-bs-toggle="tooltip" data-bs-title="noon on November 24, 4714 BCE"}. To convert a Julian date into a dote, we simply subtract 1721120.5 days ($dote = julian - 1721120.5$).


### ISO

#### Ordinal

#### Month

#### Week

### Dec

#### Date

#### Dote

The `year+day` format of Dec dates is based on the year of the [era](https://en.wikipedia.org/wiki/Calendar_era#:~:text=the%20period%20of%20time%20elapsed%20since%20one%20epoch%20of%20a%20calendar) (yote) equation: $\colorbox{yellow}{y}{=}\lfloor\colorbox{yellow}{y}\rfloor{+}\colorbox{cyan}{d}{\div}\colorbox{orange}{n}$, where $\colorbox{yellow}{y}$ is the number of [decimal](https://en.wikipedia.org/wiki/Decimal#:~:text=denoting%20integer%20and-,non%2Dinteger%20numbers,-.%20It%20is%20the) years that have passed since the Dec [epoch](https://en.wikipedia.org/wiki/Epoch#:~:text=an%20instant%20in%20time%20chosen%20as%20the%20origin%20of%20a%20particular%20calendar%20era) ([Year 0]{.underline .blue data-bs-toggle="tooltip" data-bs-title="1 BC"} [Day 0]{.underline .blue data-bs-toggle="tooltip" data-bs-title="March 1"}), $\lfloor\colorbox{yellow}{y}\rfloor$ is the [integer](https://en.wikipedia.org/wiki/Integer#:~:text=the%20number%20zero%20%280%29%2C%20a%20positive%20natural%20number%20%281%2C%202%2C%203%2C%20.%20.%20.%29%2C%20or%20the%20negation%20of%20a%20positive%20natural%20number%20%28%E2%88%921%2C%20%E2%88%922%2C%20%E2%88%923%2C%20.%20.%20.%29) year obtained by [flooring](https://en.wikipedia.org/wiki/Floor_and_ceiling_functions#:~:text=the%20greatest%20integer%20less%20than%20or%20equal%20to%20x) $\colorbox{yellow}{y}$, $\colorbox{cyan}{d}$ is the [zero-based](https://en.wikipedia.org/wiki/Zero-based_numbering#:~:text=a%20way%20of%20numbering%20in%20which%20the%20initial%20element%20of%20a%20sequence%20is%20assigned%20the%20index%C2%A00) day of the year, and $\colorbox{orange}{n}$ is the total number of days in the year.

The current yote equation values are: \${styledFracYear}=\${styledDecoYear}+\${styledDecoDate}/\${styledNdays}. Dec dates only include the first two terms from the [right-hand side](https://en.wikipedia.org/wiki/Sides_of_an_equation#:~:text=The%20expression%20on%20the%20right%20side%20of%20the%20%22%3D%22%20sign) of the yote equation ($\lfloor\colorbox{yellow}{y}\rfloor$ and $\colorbox{cyan}{d}$), because $\colorbox{orange}{n}$ is not needed to identify a specific date, only has 2 possible values (365 or 366), remains constant for long periods of time (366, 1095, or 2920 days), and is determined by $\lfloor\colorbox{yellow}{y}\rfloor$:

$$\colorbox{orange}{n}=\begin{cases}
  366&{\begin{align}\text{if } (\lfloor \colorbox{yellow}{y}\rfloor+1)\text{ \% }4=0\\
  \land(\lfloor \colorbox{yellow}{y}\rfloor+1)\text{ \% }100\neq0\\
  \lor(\lfloor \colorbox{yellow}{y}\rfloor+1)\text{ \% }400=0\end{align}}\\\\
  365&{\text{otherwise.}}\end{cases}$$

In the Dec year length equation above, $\text\%$ is the [modulo](https://en.wikipedia.org/wiki/Modulo#:~:text=returns%20the%20remainder) operator, $\land$ is the logical [conjunction](https://en.wikipedia.org/wiki/Logical_conjunction) operator (and), and $\lor$ is the logical [disjunction](https://en.wikipedia.org/wiki/Logical_disjunction) operator (or). The easiest way to explain this equation is in terms of the [Gregorian calendar](https://en.wikipedia.org/wiki/Gregorian_calendar#:~:text=the%20calendar%20used%20in%20most%20parts%20of%20the%20world): the length of a Dec year ($\colorbox{orange}{n}$) is 366 days if the subsequent year [($\lfloor\colorbox{yellow}{y}\rfloor{+}1$)]{.nowrap} is a Gregorian calendar [leap year](https://en.wikipedia.org/wiki/Leap_year#:~:text=Every%20year%20that%20is%20exactly%20divisible%20by%20four%20is%20a%20leap%20year%2C%20except%20for%20years%20that%20are%20exactly%20divisible%20by%20100%2C%20but%20these%20centurial%20years%20are%20leap%20years%20if%20they%20are%20exactly%20divisible%20by%20400) and 365 days otherwise.

In addition to calculating $\colorbox{orange}{n}$, Dec uses the Gregorian calendar leap year rule to convert Dec dates to and from  [ordinal dates](https://en.wikipedia.org/wiki/ISO_8601#Ordinal_dates:~:text=an%20ordinal%20format%20for%20the%20multiples%20of%20a%20day%20elapsed%20since%20the%20start%20of%20year), as shown in the code below.
On the surface, the only difference between Dec and ISO 8601 ordinal dates appears to be their [delimiters](https://en.wikipedia.org/wiki/Delimiter#:~:text=a%20sequence%20of%20one%20or%20more%20characters%20for%20specifying%20the%20boundary%20between%20separate%2C%20independent%20regions%20in%20plain%20text) (`+` versus `-`), but they also have different first day of the year values ([0 versus 1](https://en.wikipedia.org/wiki/Zero-based_numbering#:~:text=a%20way%20of%20numbering%20in%20which%20the%20initial%20element%20of%20a%20sequence%20is%20assigned%20the%20index%C2%A00)), epochs ([0000+000]{.underline .blue data-bs-toggle="tooltip" data-bs-title="March 1st, 1 BCE"} versus [00-1+306]{.underline .blue data-bs-toggle="tooltip" data-bs-title="January 1st, 1 BCE"}), and year length equations ($\lfloor\colorbox{yellow}{y}\rfloor{+}1$ versus $\lfloor\colorbox{yellow}{y}\rfloor$).

::: {.content-hidden unless-profile="javascript"}
::: {.content-hidden unless-format="ipynb"}
::: {.content-hidden when-meta="knitr"}

# JavaScript

```{typescript}
//| eval: false
//| tags: [js, func, leap]
function leap(year = 1969) {
  return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}
function year2dity(year = 1969) {
  return 365 + leap(year + 1)
}
function date2isoo(year = 1969, doty = 306) {
  return [year + (doty > 305),
          (doty + 59 + leap(year)) % (365 + leap(year)) + 1]
}
function isoo2date(year = 1970, doty = 1) {
  return [year - (doty < (60 + leap(year))),
          (doty + 305) % (365 + leap(year))]
}
console.log(leap())
console.log(year2dity())
console.log(date2isoo())
console.log(isoo2date())
```

:::
:::
:::

::: {.content-hidden unless-profile="julia"}
::: {.content-hidden unless-format="ipynb"}
::: {.content-hidden when-meta="knitr"}

<!-- # Julia -->

<!-- ```{julia} -->
<!-- #| eval: false -->
<!-- #| tags: [jl, func, leap] -->
<!-- function leap(year = 1969) -->
<!--     return year % 4 == 0 && year % 100 != 0 || year % 400 == 0 -->
<!-- end -->
<!-- function year2dity(year = 1969) -->
<!--     return 365 + leap(year + 1) -->
<!-- end -->
<!-- function date2isoo(year::Int = 1969, doty::Int = 306) -->
<!--     return (year + (doty > 305), -->
<!--         (doty + 59 + leap(year)) % (365 + leap(year)) + 1) -->
<!-- end -->
<!-- function isoo2date(year::Int = 1970, doty::Int = 1) -->
<!--     return (year - (doty < (60 + leap(year)) ? 1 : 0), -->
<!--         (doty + 305) % (365 + leap(year))) -->
<!-- end -->
<!-- println(leap()) -->
<!-- println(year2dity()) -->
<!-- println(date2isoo()) -->
<!-- println(isoo2date()) -->
<!-- ``` -->

:::
:::
:::

::: {.content-hidden unless-profile="lua"}
::: {.content-hidden unless-format="ipynb"}
::: {.content-hidden when-meta="knitr"}

# Lua

```{lua}
--| eval: false
--| tags: [lua, func, leap]
function leap(year)
    year = year or 1969
    return (year % 4 == 0 and year % 100 ~= 0) or (year % 400 == 0)
end
function year2dity(year)
    year = year or 1969
    return 365 + (leap(year + 1) and 1 or 0)
end
function date2isoo(year, doty)
    year = year or 1969
    doty = doty or 306
    return year + (doty > 305 and 1 or 0),
        (doty + 59 + (leap(year) and 1 or 0))
        % (365 + (leap(year) and 1 or 0)) + 1
end
function isoo2date(year, doty)
    year = year or 1970
    doty = doty or 1
    return year - (doty < (60 + (leap(year) and 1 or 0)) and 1 or 0),
        (doty + 305) % (365 + (leap(year) and 1 or 0))
end
print(leap())
print(year2dity())
print(date2isoo())
print(isoo2date())
```

:::
:::
:::

::: {.content-hidden unless-profile="python"}
::: {.content-hidden unless-format="ipynb"}
::: {.content-hidden when-meta="knitr"}

# Python

```{python}
#| eval: false
#| tags: [py, func, leap]
def leap(year=1969):
    return year % 4 == 0 and year % 100 != 0 or year % 400 == 0
def year2dity(year=1969):
    return 365 + leap(year + 1)
def date2isoo(year=1969, doty=306):
    return (year + (doty > 305),
        (doty + 59 + leap(year)) % (365 + leap(year)) + 1)
def isoo2date(year=1970, doty=1):
    return (year - (doty < (60 + leap(year))),
        (doty + 305) % (365 + leap(year)))
leap()
year2dity()
date2isoo()
isoo2date()
```

:::
:::
:::

::: {.content-hidden unless-profile="r"}
::: {.content-hidden unless-format="ipynb"}
::: {.content-hidden when-meta="knitr"}

# R

```{r}
#| eval: false
#| tags: [r, func, leap]
leap <- function(year = 1969) {
  year %% 4 == 0 & year %% 100 != 0 | year %% 400 == 0
}
year2dity <- function(year = 1969) {
  365 + leap(year + 1)
}
date2isoo <- function(year = 1969, doty = 306) {
  c(year + (doty > 305),
    (doty + 59 + leap(year)) %% (365 + leap(year)) + 1)
}
isoo2date <- function(year = 1970, doty = 1) {
  c(year - (doty < (60 + leap(year))),
    (doty + 305) %% (365 + leap(year)))
}
leap()
year2dity()
date2isoo()
isoo2date()
```

:::
:::
:::

::: {.content-hidden unless-profile="bash"}
::: {.content-hidden unless-format="ipynb"}
::: {.content-hidden when-meta="knitr"}

# Shell

```{bash}
#| eval: false
#| tags: [sh, func, leap]
leap() {
    year=${1:-1969}
    echo $(( (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0) ))
}
year2dity() {
    year=${1:-1969}
    echo $(( 365 + $(leap $(( year + 1 ))) ))
}
date2isoo() {
    year=${1:-1969}
    doty=${2:-306}
    echo "$(( year + (doty > 305) ))-$(( (doty + 59 + $(leap $year)) % (365 + $(leap $year)) + 1 ))"
}
isoo2date() {
    year=${1:-1970}
    doty=${2:-1}
    echo "$(( year - (doty < (60 + $(leap $year)) ? 1 : 0) ))-$(( (doty + 305) % (365 + $(leap $year)) ))"
}
leap
year2dity
date2isoo
isoo2date
```

:::
:::
:::

Dec dates can also be easily converted to and from ISO 8601 month dates. 


```{=html}
<style>
   #dec > g.cluster-label {
     transform: translate(252px, 86px) !important;
   }
   #iso > g.cluster-label {
     transform: translate(492px, 36px) !important;
   }
   span.cal-swatch {
     font-size: 14px !important;
     margin-bottom: -25px;
  }
  .calplot {
     margin-bottom: -40px;
  }
</style>
```

Press the Playâ–¶ï¸button below to cycleðŸ”„through every Dec day of the year (doty) and its corresponding month and day of the month (dotm). Or use the [range inputs](https://observablehq.com/documentation/inputs/overview#range) below to select a doty of personal or historical significance, like your birthdayðŸŽ‚ or [Day 110](https://en.wikipedia.org/wiki/Juneteenth#:~:text=celebrated%20annually%20on%20June%2019%20to%20commemorate%20the%20ending%20of%20slavery%20in%20the%20United%20States){.underline .blue data-bs-toggle="tooltip" data-bs-title="Juneteenth"}. The calendar plot below highlights the selected doty with a red box, distinguishes months with colors, and shows the week of the year (woty) and day of the week (dotw) on its y- and x-axes, respectively.

```{ojs}
//| echo: false
viewof scrubberDoty = Scrubber(numbers, {autoplay: false, alternate: true, delay: 86.4, loopDelay: 864, format: y => "", inputStyle: "display:none;"})
viewof dotyInput = Inputs.range([0, 365], {value: 306, step: 1, label: "day of the year"});
viewof monthInput = transformInput(
    Inputs.range([1, 12], {step: 1, label: "month"}),
    {bind: viewof dotyInput, transform: doty2month, invert: month2doty}
);
viewof dotmInput = transformInput(
    Inputs.range([1, 31], {step: 1, label: "day of the month"}),
    {bind: viewof dotyInput, transform: doty2dotm, invert: (x => Math.floor(( 153 * (
        viewof monthInput.value > 2
        ? viewof monthInput.value - 3
        : viewof monthInput.value + 9) + 2
    ) / 5 + x - 1
))});
calPlot = Plot.plot({
  padding: 0,
  className: "calplot",
  x: {tickFormat: Plot.formatWeekday("en", "long"), tickSize: 0, axis: "top"},
  //fx: {tickFormat: ""},
  style: { fontSize: 14 },
  color: {
    scheme: "Pastel2",
    legend: true,
    domain: months.slice(monthInput > 1 ? monthInput - 2: monthInput - 1, monthInput + 1),
    className: "cal",
  },
  marks: [
    Plot.cell(datesCal, {
      y: d => d3.utcWeek.count(d3.utcYear(d), d),
      x: d => d.getUTCDay(),
      //fx: d => d.getUTCFullYear(),
      fill: d => months[d.getUTCMonth()],
      stroke: d => Math.floor(unix2doty(d.getTime())) === dotyInput ? "red" : "none",
      strokeWidth: 3,
      inset: 0.5,
    }),
    Plot.text(datesCal, {
    y: d => d3.utcWeek.count(d3.utcYear(d), d),
    x: d => d.getUTCDay(),
    //fx: d => d.getUTCFullYear(),
    fill: "black",
    //stroke: "white",
    text: d => Math.floor(unix2doty(d.getTime())).toString().padStart(3, "0"),
    monospace: true,
    fontSize: 16})
  ]
})
move = {
  d3.select(calPlot)
    .select("div.cal-swatches")
    .raise() // Places swatch below the plot
    .style("float", "right"); // Floats the swatch on the right.
}
```

Week and dotw values vary from year to year in a pattern called the solar cycle. Dec has no need for weeks, but uses solar cycles to convert Dec dates into days of the era (dotes). A day of the era (dote) is a continuous count of days since the Dec epoch which can be used for [calendrical calculations](https://en.wikipedia.org/wiki/Calendrical_calculation#:~:text=calculation%20concerning%20calendar%20dates) or converted into a dotw or an ISO 8601 [week date](https://en.wikipedia.org/wiki/ISO_week_date#:~:text=a%20leap%20week%20calendar%20system) as shown below.

::: {.content-hidden unless-profile="knitr"}
::: {.content-hidden unless-meta="knitr"}
::: {.content-hidden unless-format="html"}
::: {.panel-tabset }

# JavaScript

{{< embed index.js.ipynb#unix2date echo=true >}}

# Julia

{{< embed index.jl.ipynb#unix2date echo=true >}}

# Lua

{{< embed index.lua.ipynb#unix2date echo=true >}}

# Python

{{< embed index.py.ipynb#unix2date echo=true >}}

# R

{{< embed index.r.ipynb#unix2date echo=true >}}

:::
:::
:::
:::

If we ever need to convert between a doty and a Gregorian calendar month and day of the month without any conversion tools, we can use the Dec finger mnemonic, which is similar to the [knuckle mnemonic](https://en.wikipedia.org/wiki/Knuckle_mnemonic#:~:text=a%20mnemonic%20device%20for%20remembering%20the%20number%20of%20days%20in%20the%20months%20of%20the%20Julian%20and%20Gregorian%20calendars). The numbers above the fingers in the image below indicate the doty of the last day of each Gregorian calendar month. The thumb, middle finger, and pinky represent months with 31 days, whereas the index and ring fingers stand for 30-day months.

![Dec finger mnemonic](/asset/finger.svg)

The [southward equinox](https://en.wikipedia.org/wiki/September_equinox#:~:text=the%20moment%20when%20the%20Sun%20appears%20to%20cross%20the%20celestial%20equator%2C%20heading%20southward) falls on Day 205 in Year 2024, 2025, 2028, and 2029. We can determine that Day 205 is September 22 by subtracting the Dec date of the last day of August (Day 183), the month preceding September, from the southward equinox doty: $205{-}183{=}22$. To convert in the other direction, we would sum the doty and the day of the month: $183{+}22{=}205$.

The finger mnemonic highlights a major difference between Dec and the Gregorian calendar: the Dec year starts on [Day 0]{.underline .blue data-bs-toggle="tooltip" data-bs-title="March 1"} just like the [Roman calendar](https://en.wikipedia.org/wiki/Roman_calendar#:~:text=the%20calendar%20used%20by%20the%20Roman%20Kingdom%20and%20Roman%20Republic), the predecessor of the Gregorian and Julian calendars. For this reason, the Latin [numeral prefixes](https://en.wikipedia.org/wiki/Numeral_prefix#:~:text=prefixes%20derived%20from%20numerals) in the names of the months of [Septem](https://en.wikipedia.org/wiki/Numeral_prefix#:~:text=7-,septem,-%2D%2C%20septi%2D%5B)ber, [Octo](https://en.wikipedia.org/wiki/Numeral_prefix#:~:text=8-,octo,-%2D%5Bu)ber, [Novem](https://en.wikipedia.org/wiki/Numeral_prefix#:~:text=9-,novem,-%2D%5Bx)ber, and [Decem](https://en.wikipedia.org/wiki/Numeral_prefix#:~:text=10-,decem,-%2D%2C%20dec%2D%5B)ber match their one-based indexes (7, 8, 9, and 10) in Dec and the Roman calendar, but not in the Julian or Gregorian calendars.

The knuckle and finger mnemonics attempt to make sense of the irregular pattern of month lengths in the Gregorian calendar. Rather than replace variable-length months with [fixed-length months](https://en.wikipedia.org/wiki/Calendar_reform#13-month_calendars), Dec forgoes the use of months entirely and instead uses groups of ten days called deks.


I generate all of the dates on my site from [UNIX time](https://en.wikipedia.org/wiki/Unix_time#:~:text=the%20number%20of%20non%2Dleap%20seconds%20that%20have%20elapsed%20since%2000%3A00%3A00%20UTC%20on%201st%C2%A0January%201970%2C%20the%20Unix%20epoch) using calculations that I adapted from the [`civil_from_days`](https://howardhinnant.github.io/date_algorithms.html#civil_from_days) function in [Howard Hinnant](https://howardhinnant.github.io)'s [`date` library](https://howardhinnant.github.io/date/date.html).
Each tab in the [tabset panel](https://quarto.org/docs/interactive/layout.html#:~:text=Tabset%20Panel,-If%20you%20want%20to%20allow) below shows a different implementation of a function called `unix2date` which converts UNIX time into `year+day` dates.

In this function, `socy` is an abbreviation for solar cycle and `dote`, `dotc`,  and `yotc` are acronyms for "day of the era", "day of the cycle", and "day of the cycle", respectively. A solar cycle in the Gregorian calendar is [400 years](https://en.wikipedia.org/wiki/Solar_cycle_%28calendar%29#:~:text=400%2Dyear%20cycle%20of%20the%20Gregorian%20calendar). A [calendar era](https://en.wikipedia.org/wiki/Calendar_era#:~:text=the%20period%20of%20time%20elapsed%20since%20one%20epoch%20of%20a%20calendar) is the time that has passed since a starting point called a [calendar epoch](https://en.wikipedia.org/wiki/Epoch#:~:text=an%20instant%20in%20time%20chosen%20as%20the%20origin%20of%20a%20particular%20calendar%20era). The Dec epoch is [Year 0 Day 0]{.underline .blue data-bs-toggle="tooltip" data-bs-title="0000-03-01"}.


I use different programming languages to convert UNIX time in various places on my site. More specifically, I use a [Python](https://en.wikipedia.org/wiki/Python_%28programming_language%29#:~:text=a%20high%2Dlevel%2C%20general%2Dpurpose%20programming%20language) [post-render script](https://quarto.org/docs/projects/scripts.html#pre-and-post-render) ([date.py](/asset/date.py)) for the dates on the [page that lists all of the articles on my site](/list), a [Lua](https://en.wikipedia.org/wiki/Lua_(programming_language)#:~:text=a%20lightweight%2C%20high%2Dlevel%2C%20multi%2Dparadigm%20programming%20language%20designed%20mainly%20for%20embedded%20use%20in%20applications) [filter](https://quarto.org/docs/extensions/filters.html) ([date.lua](/asset/date.lua)) for the PUBLISHED date at the top of each article, and an [include-after-body file](https://quarto.org/docs/output-formats/html-basics.html#includes) that sources a [JavaScript](https://en.wikipedia.org/wiki/JavaScript#:~:text=a%20programming%20language%20and%20core%20technology%20of%20the%20Web) file ([stamp.js](/asset/stamp.js)) for the date in the  above. [citation](http://localhost:4207/dec/date/#citation) information at the bottom of each article.

::: {.content-hidden unless-profile="javascript"}
::: {.content-hidden unless-format="ipynb"}
::: {.content-hidden when-meta="knitr"}

# JavaScript

```{typescript}
//| eval: false
//| tags: [js, func, unix2date]
function unix2date(unix) {
  const dote = unix / 86400 + 719468,
    socy = Math.floor((
      dote >= 0 ? dote
      : dote - 146096
    ) / 146097),
  dotc = dote - socy * 146097,
  yotc = Math.floor((dotc
    - Math.floor(dotc / 1460)
    + Math.floor(dotc / 36524)
    - Math.floor(dotc / 146096)
  ) / 365);
  return [
    yotc + socy * 400,
    dotc - (yotc * 365
      + Math.floor(yotc / 4)
      - Math.floor(yotc / 100)
  )]}
unix2date(1728000000)
unix2date(1890000000)
```

:::
:::
:::

::: {.content-hidden unless-profile="julia"}
::: {.content-hidden unless-format="ipynb"}
::: {.content-hidden when-meta="knitr"}

<!-- # Julia -->

<!-- ```{julia} -->
<!-- #| eval: false -->
<!-- #| tags: [jl, func, unix2date] -->
<!-- function unix2date(unix) -->
<!--     dote = unix / 86400 + 719468 -->
<!--     socy = ( -->
<!--         dote >= 0 ? dote -->
<!--         : dote - 146096 -->
<!--         ) Ã· 146097 -->
<!--     dotc = dote - socy * 146097 -->
<!--     yotc = ( -->
<!--         dotc - dotc Ã· 1460 -->
<!--         + dotc Ã· 36524 -->
<!--         - dotc Ã· 146096 -->
<!--     ) Ã· 365 -->
<!--     return Int( -->
<!--         yotc + socy * 400), -->
<!--     dotc - (yotc * 365 -->
<!--         + yotc Ã· 4 -->
<!--         - yotc Ã· 100) -->
<!-- end -->
<!-- unix2date(1728000000) -->
<!-- unix2date(1890000000) -->
<!-- ``` -->

:::
:::
:::

::: {.content-hidden unless-profile="lua"}
::: {.content-hidden unless-format="ipynb"}
::: {.content-hidden when-meta="knitr"}

# Lua

```{lua}
--| eval: false
--| tags: [lua, func, unix2date]
function unix2date(unix)
  local dote = unix / 86400 + 719468
  local socy = (
    dote >= 0 and dote
    or dote - 146096
  ) // 146097
  local dotc = dote - socy * 146097
  local yotc = (
    dotc - dotc // 1460
    + dotc // 36524
    - dotc // 146096
  ) // 365
  return {
    math.floor(yotc + socy * 400),
    dotc - (yotc * 365
      + yotc // 4
      - yotc // 100
  )}
end
unix2date(1728000000)
unix2date(1890000000)
```

:::
:::
:::

::: {.content-hidden unless-profile="python"}
::: {.content-hidden unless-format="ipynb"}
::: {.content-hidden when-meta="knitr"}

# Python

```{python}
#| eval: false
#| tags: [py, func, unix2date]
def unix2date(unix):
    dote = unix / 86400 + 719468
    socy = (
        dote if dote >= 0
        else dote - 146096
    ) // 146097
    dotc = dote - socy * 146097
    yotc = (dotc
        - dotc // 1460
        + dotc // 36524
        - dotc // 146096
    ) // 365
    return [
        int(yotc + socy * 400),
        dotc - (yotc * 365
            + yotc // 4
            - yotc // 100
    )]
unix2date(1728000000)
unix2date(1890000000)
```

:::
:::
:::

::: {.content-hidden unless-profile="r"}
::: {.content-hidden unless-format="ipynb"}
::: {.content-hidden when-meta="knitr"}

# R

```{r}
#| eval: false
#| tags: [r, func, unix2date]
unix2date <- function(unix) {
  dote = unix / 86400 + 719468
  socy = ifelse(
    dote >= 0, dote,
    dote - 146096
  ) %/% 146097
  dotc = dote - socy * 146097
  yotc = (
    dotc - dotc %/% 1460
    + dotc %/% 36524
    - dotc %/% 146096
  ) %/% 365
  c(
    yotc + socy * 400,
    dotc - (yotc * 365
      + yotc %/% 4
      - yotc %/% 100
))}
unix2date(1728000000)
unix2date(1890000000)
```

:::
:::
:::

::: {.content-hidden unless-profile="bash"}
::: {.content-hidden unless-format="ipynb"}
::: {.content-hidden when-meta="knitr"}

# Bash

```{bash}
#| eval: false
#| tags: [sh, func, unix2date]
unix2date() {
    local unix=${1:-$(date +%s)}
    local dote=$(echo "scale=0; $unix / 86400 + 719468" | bc)
    if [ $(echo "$dote >= 0" | bc) -eq 1 ]; then
        local socy=$(echo "scale=0; $dote / 146097" | bc)
    else
        local socy=$(echo "scale=0; ($dote - 146096) / 146097" | bc)
    fi
    local dotc=$(echo "scale=0; $dote - $socy * 146097" | bc)
    local yotc=$(echo "scale=0; ($dotc - $dotc / 1460 + $dotc / 36524 - $dotc / 146096) / 365" | bc)
    echo "$(echo "$yotc + $socy * 400" | bc) $(echo "$dotc - ($yotc * 365 + $yotc / 4 - $yotc / 100)" | bc)"
}
unix2date 1728000000
unix2date 1890000000
```

:::
:::
:::

```{ojs}
//| echo: false
//| output: false
unix = {
  while(true) {
    yield Date.now();
  }
}
// http://howardhinnant.github.io/date_algorithms.html#civil_from_days
function unix2dote(unix, zone) {
  return [
    (unix ?? Date.now()) / 86400000
    + (zone = zone ?? (
      10 - Math.round((new Date)
        .getTimezoneOffset() / 144)
    ) % 10) / 10 + 719468, zone]}
function dote2doty(dote, zone = 0) {
  const socy = Math.floor((
      dote >= 0 ? dote
      : dote - 146096
    ) / 146097),
  dotc = dote - socy * 146097,
  yotc = Math.floor((dotc
    - Math.floor(dotc / 1460)
    + Math.floor(dotc / 36524)
    - Math.floor(dotc / 146096)
  ) / 365);
  return [
    yotc + socy * 400,
    dotc - (yotc * 365
      + Math.floor(yotc / 4)
      - Math.floor(yotc / 100)
  ), zone]}
function doty2deco0(year = 1969, doty = 306, zone = 0) {
  return `${year.toString().padStart(4, "0")}+${Math.floor(doty).toString().padStart(3, "0")}${String(doty % 1 * 10).slice(0, 6)}-${zone}`
}
ydz = dote2doty(...unix2dote(unix))
deco = doty2deco0(...ydz)
// https://observablehq.com/@observablehq/text-color-annotations-in-markdown#textcolor
function setStyle(content, style = {}) {
  function yiq(color) {
    const {r, g, b} = d3.rgb(color);
    return (r * 299 + g * 587 + b * 114) / 1000 / 255; // returns values between 0 and 1
  }
  const {
    background,
    color = yiq(background) >= 0.6 ? "#111" : "white",
    padding = "0 1px",
    borderRadius = "4px",
    fontWeight = 900,
    fontSize = "1em",
    ...rest
  } = typeof style === "string" ? {background: style} : style;
  return htl.html`<span style=${{
    background,
    color,
    padding,
    borderRadius,
    fontWeight,
    ...rest
  }}>${content}</span>`;
}
function year2leap(year = 1970) {
    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}
decoYear = deco.slice(0, 4)
decoDate = deco.slice(5, 8)
nDaysInYear = 365 + year2leap(ydz[0] + 1)
fracYear = (ydz[0] + (ydz[1] - ydz[2]) / nDaysInYear).toFixed(3)
styledDecoYear = setStyle(decoYear, d3.schemePaired[10])
styledFracYear = setStyle(fracYear, d3.schemePaired[10])
styledDecoDate = setStyle(decoDate, d3.color("cyan").formatHex())
styledDecoDate1 = setStyle(decoDate, d3.color("cyan").formatHex())
styledDecoDek = setStyle(decoDate.slice(0, 2), d3.color("cyan").formatHex())
styledDecoDotd = setStyle(decoDate[2], d3.color("cyan").formatHex())
styledNdays = setStyle(nDaysInYear, d3.schemePaired[6])
// https://observablehq.com/@juang1744/transform-input/1
transformInput = function(target, {bind: source, transform = identity, involutory = false, invert = involutory ? transform : inverse(transform)} = {}){
  if (source === undefined) {
    source = target;
    target = html`<div>${source}</div>`;
  }
  function sourceInputHandler() {
    target.removeEventListener("input", targetInputHandler);
    setTransform(target).to(transform(source.value)).andDispatchEvent();
    target.addEventListener("input", targetInputHandler);
  }
  function targetInputHandler() {
    source.removeEventListener("input", sourceInputHandler);
    setTransform(source).to(invert(target.value)).andDispatchEvent();
    source.addEventListener("input", sourceInputHandler);
  }
  source.addEventListener("input", sourceInputHandler);
  target.addEventListener("input", targetInputHandler);
  invalidation.then(() => {
    source.removeEventListener("input", sourceInputHandler);
    target.removeEventListener("input", targetInputHandler);
  });
  sourceInputHandler();
  return target;
}
setTransform = (input) => ({to: (value) => (input.value = value, {andDispatchEvent: (event = new Event("input")) => input.dispatchEvent(event)})});
function inverse(f) {
  switch (f) {
    case identity:  return identity;
    case Math.sqrt: return square;
    case Math.log:  return Math.exp;
    case Math.exp:  return Math.log;
    default:        return (x => solve(f, x, x));
  }
  function solve(f, y, x = 0) {
    const dx = 1e-6;
    let steps = 100, deltax, fx, dfx;
    do {
      fx = f(x)
      dfx = (f(x + dx) - fx) || dx;
      deltax = dx * (fx - y)/dfx
      x -= deltax;
    } while (Math.abs(deltax) > dx && --steps > 0);
    return steps === 0 ? NaN : x;
  }
function square(x) {
    return x * x;
  }
}
function identity(x) {
  return x;
}
function doty2month(doty = 0) {
    const m = Math.floor((5 * doty + 2) / 153);
    return Math.floor(m < 10 ? m + 3 : m - 9);
}
function month2doty(month = 1) {
    return Math.floor(
        (153 * (month > 2 ? month - 3 : month + 9) + 2) / 5
)}
function doty2dotm(doty = 0) {
    const m = Math.floor((5 * doty + 2) / 153);
    return doty - Math.floor((153 * m + 2) / 5) + 1;
}
numbers = Array.from({length: 366}, (_, i) => i)
set(viewof dotyInput, scrubberDoty)
// https://observablehq.com/@observablehq/synchronized-inputs
function set(input, value) {
  input.value = value;
  input.dispatchEvent(new Event("input", {bubbles: true}));
}
// https://observablehq.com/@mbostock/scrubber
function Scrubber(values, {
  format = value => value,
  initial = 0,
  direction = 1,
  delay = null,
  autoplay = true,
  loop = true,
  loopDelay = null,
  alternate = false,
  inputStyle = ""
} = {}) {
  values = Array.from(values);
  const form = html`<form style="font: 18px var(--monospace); font-variant-numeric: tabular-nums; display: flex; height: 33px; align-items: center;">
  <button name=b type=button style="margin-right: 0.4em; width: 5em;"></button>
  <label style="display: flex; align-items: center;">
    <input name=i type=range min=0 max=${values.length - 1} value=${initial} step=1 style=${inputStyle}>
    <output name=o style="margin-left: 0.4em;"></output>
  </label>
</form>`;
  let frame = null;
  let timer = null;
  let interval = null;
  function start() {
    form.b.textContent = "Pause";
    if (delay === null) frame = requestAnimationFrame(tick);
    else interval = setInterval(tick, delay);
  }
  function stop() {
    form.b.textContent = "Play";
    if (frame !== null) cancelAnimationFrame(frame), frame = null;
    if (timer !== null) clearTimeout(timer), timer = null;
    if (interval !== null) clearInterval(interval), interval = null;
  }
  function running() {
    return frame !== null || timer !== null || interval !== null;
  }
  function tick() {
    if (form.i.valueAsNumber === (direction > 0 ? values.length - 1 : direction < 0 ? 0 : NaN)) {
      if (!loop) return stop();
      if (alternate) direction = -direction;
      if (loopDelay !== null) {
        if (frame !== null) cancelAnimationFrame(frame), frame = null;
        if (interval !== null) clearInterval(interval), interval = null;
        timer = setTimeout(() => (step(), start()), loopDelay);
        return;
      }
    }
    if (delay === null) frame = requestAnimationFrame(tick);
    step();
  }
  function step() {
    form.i.valueAsNumber = (form.i.valueAsNumber + direction + values.length) % values.length;
    form.i.dispatchEvent(new CustomEvent("input", {bubbles: true}));
  }
  form.i.oninput = event => {
    if (event && event.isTrusted && running()) stop();
    form.value = values[form.i.valueAsNumber];
    form.o.value = format(form.value, form.i.valueAsNumber, values);
  };
  form.b.onclick = () => {
    if (running()) return stop();
    direction = alternate && form.i.valueAsNumber === values.length - 1 ? -1 : 1;
    form.i.valueAsNumber = (form.i.valueAsNumber + direction) % values.length;
    form.i.dispatchEvent(new CustomEvent("input", {bubbles: true}));
    start();
  };
  form.i.oninput();
  if (autoplay) start();
  else stop();
  Inputs.disposal(form).then(stop);
  return form;
}

startCal = new Date(monthInput < 3 ? decoYear + 1 : decoYear, monthInput > 1 ? monthInput - 2 : monthInput - 1, 0);
endCal = new Date(monthInput < 3 ? decoYear + 1 : decoYear, monthInput < 12 ? monthInput + 1 : monthInput, 0);
datesCal = d3.utcDays(startCal, endCal);
months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
function unix2doty(unix) {
  const dote = (
    unix ?? Date.now()
  ) / 86400000 + 719468,
    socy = Math.floor((
      dote >= 0 ? dote
      : dote - 146096
    ) / 146097),
  dotc = dote - socy * 146097,
  yotc = Math.floor((dotc
    - Math.floor(dotc / 1460)
    + Math.floor(dotc / 36524)
    - Math.floor(dotc / 146096)
  ) / 365);
  return dotc - (yotc * 365
      + Math.floor(yotc / 4)
      - Math.floor(yotc / 100)
  )}

function doty2dote(year = 1969, doty = 0, zone = 0) {
    const cycle = Math.floor((year >= 0 ? year : year - 399) / 400),
    yote = year - cycle * 400;
    return cycle * 146097 + yote * 365 + Math.floor(yote / 4) - Math.floor(yote / 100) + doty - zone
}
function doty2deco(yearDoty = [1969, 306], zone = 0) {
    const yd = dote2doty(doty2dote(yearDoty[0], Math.floor(yearDoty[1])));
    return `${yd[0].toString().padStart(4, "0")}+${yd[1].toString().padStart(3, "0")}${
        yearDoty[1].toString().includes(".") ? "." + (
            (yearDoty[1] > 0) ? (yearDoty[1] - zone).toString().split(".").pop()
            : [...(yearDoty[1] - zone).toString().split(".").pop()].map(
                (e, i, a) => (i + 1 === a.length) ? 10 - e : 9 - e
            ).join("")
        ) : ""
    }`
}
function deco2doty(timestamp = "1969+306.00000Z") {
    const arr = timestamp.toString().split(/(?=[+-]|[a-zA-Z])/, 3);
    switch (arr.length) {
        case 1: return [unix2doty(Date.now())[0], parseFloat(arr[0]), 0];
        case 2: return (/^[a-zA-Z]+$/.test(arr[1]))
            ? [unix2doty(Date.now())[0], parseFloat(arr[0]), zone2hour(arr[1]) / 24]
            : [parseFloat(arr[0]), parseFloat(arr[1]), 0];
    };
    return [parseFloat(arr[0]), parseFloat(arr[1]), /^[a-zA-Z]+$/.test(arr[2])
        ? zone2hour(arr[2]) / 24
        : parseFloat(arr[2].replace(/([+-])/, "$1\."))];
}
function zone2hour(zone = "Z") {
    return (zone = zone.toUpperCase()) == "Z" ? 0
        : zone > "@" && zone < "J" ? zone.charCodeAt() - 64
        : zone > "J" && zone < "N" ? zone.charCodeAt() - 65
        : zone < "Z" && zone > "M" ? -(zone.charCodeAt() - 77)
        : zone;
}
function doty2unix(year = 1969, doty = 306, zone = 0) {
    return (doty2dote(year, doty, zone) - 719468) * 86400000;
}
function doty2isoc(yd) {
    return new Date(doty2unix(...yd))
}
function doty2greg(doty = 306) {
    const m = Math.floor((5 * doty + 2) / 153);
    return [
      Math.floor(m < 10 ? m + 3 : m - 9),
      Math.floor(doty - (153 * m + 2) / 5 + 2)
    ];
}
function greg2doty(month = 1, day = 1) {
    return Math.floor(
        (153 * (month > 2 ? month - 3 : month + 9) + 2) / 5 + day - 1
)}
function greg2year(year = 1970, month = 1) { return year - (month < 3) }
function isoc2doty(isoc) {
  return [greg2year(isoc.getFullYear(), isoc.getUTCMonth() + 1), greg2doty(isoc.getUTCMonth() + 1, isoc.getUTCDate())];
}
```

