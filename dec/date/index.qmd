---
title: Dec Date
image: /asset/deidek.svg
citation:
  url: https://maptv.github.io/dec/date
license: CC BY-SA
lightbox: false
toc: true
toc-depth: 5
format:
  html:
    shift-heading-level-by: 3
    include-after-body:
      - ../../asset/cite.html
      - ../../asset/style.html
      - ../../asset/stamp.html
      - ../../asset/tooltip.html
  commonmark: default
filters:
  - ../../asset/date.lua
  - include-code-files
---

My website serves as a demonstration of both the [Quarto](https://quarto.org) publishing system and the [Dec](/dec) measurement system. I use several clever hacks to get Quarto to display all of the dates on my website in the Dec [year]{.yellow}+[day]{.cyan} format. Knowing the basics of Dec dates will help you to understand the articles on [filter](https://quarto.org/docs/extensions/filters.html), [script](https://quarto.org/docs/projects/scripts.html), and [include](https://quarto.org/docs/output-formats/html-basics.html#includes) files in the [Quarto section](/quarto) of my site.

Among its many features, Quarto offers support for the [Observable](https://observablehq.com/) data analysis and visualization system. In the Observable [calendarüóìÔ∏èplots](https://observablehq.com/@observablehq/plot-calendar) below, [Gregorian calendar](https://en.wikipedia.org/wiki/Gregorian_calendar#:~:text=the%20calendar%20used%20in%20most%20parts%20of%20the%20world) months are identified by [color](https://observablehq.com/@d3/color-schemes) and each day of the year has its own [cell](https://observablehq.com/plot/marks/cell). Despite these similarities, the two plots illustrate how the Dec (top) and Gregorian (bottom) calendars differ.

# Doty

The Dec calendar (Decalendar) starts on [Day 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="March 1"} instead of [Day 306]{.underline .tool data-bs-toggle="tooltip" data-bs-title="January 1"} and uses a single number called the day of the year (doty), the [day]{.cyan} in [year]{.yellow}+[day]{.cyan}, to serve the same purpose as months and weeks in the Gregorian calendar. The current doty and the doty selected by the [Observable](https://observablehq.com/) [range](https://observablehq.com/@observablehq/input-range)üéöÔ∏èinputs below to be highlighted in the calendarüóìÔ∏èplots are [\${decoDoty}]{.cyan} and [\${dotyInput}]{.cyan}, respectively.

::: {.column-page-right}
```{ojs}
//| echo: false
decPlot = Plot.plot({
  padding: 0,
  width: 1080,
  height: 240,
  className: "calplot",
  marginTop: -3,
  marginLeft: 31,
  marginBottom: 35,
  y: {tickSize: 0,
      label: "Day of the dek    ",
      domain: [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      ticks: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      tickPadding: -12,
      labelOffset: 22,
  },
  x: {interval: 1, ticks: 18, label: "Dek", type: "band", tickSize: 0, tickPadding: -2, labelOffset: 32},
  //fx: {tickFormat: ""},
  style: { fontSize: "21px" },
  color: {
    range: d3.schemePastel1.concat(d3.schemePastel2.slice(4, 7)).concat(d3.schemeSet1[0]),
    domain: months.concat("selected"),
    className: "cal",
  },
  marks: [
    Plot.cell(dates, {
      x: (d, i) => Math.floor(i / 10),
      y: (d, i) => i % 10,
      //fx: d => d.getUTCFullYear(),
      fill: d => Math.floor(unix2doty(d.getTime())) === dotyInput ? "selected" : months[d.getUTCMonth()],
      stroke: d => Math.floor(unix2doty(d.getTime())) === dotyInput ? "darkorange" : "none",
      strokeWidth: 3,
      inset: 0.5,
    }),
    Plot.text(dates, {
      x: (d, i) => Math.floor(i / 10),
      y: (d, i) => i % 10,
      //fx: d => d.getUTCFullYear(),
      text: d => d.getUTCDate() === 7 ? months[d.getUTCMonth()].slice(0, 3) : "",
      y: -1,
      frameAnchor: "left",
      dy: -1,
      monospace: true,
      fontSize: "18px"}),
    Plot.text(dates, {
      x: (d, i) => Math.floor(i / 10),
      y: (d, i) => i % 10,
      //fx: d => d.getUTCFullYear(),
      fill: d => Math.floor(unix2doty(d.getTime())) === dotyInput ? "white" : "black",
      //stroke: "white",
      text: (d, i) => String(i),//.padStart(3, "0").slice(1),
      monospace: true,
      fontSize: "13px"})
  ]
})
```

```{ojs}
//| echo: false
calPlot = Plot.plot({
  padding: 0,
  width: 1000,
  height: 200,
  className: "calplot",
  marginTop: 0,
  marginBottom: 40,
  marginLeft: 42,
  y: {tickFormat: Plot.formatWeekday("en", "short"), tickSize: 0,
      domain: [-1, 0, 1, 2, 3, 4, 5, 6],
      ticks: [0, 1, 2, 3, 4, 5, 6],
      tickPadding: 2,
  },
  x: {interval: 1, ticks: 26, label: "Week", type: "band", tickSize: 0, tickPadding: 2, labelOffset: 36},
  //fx: {tickFormat: ""},
  style: { fontSize: "20px" },
  color: {
    range: d3.schemePastel1.concat(d3.schemePastel2.slice(4, 7)).concat(d3.schemeSet1[0]),
    domain: months.concat("selected"),
    className: "cal",
  },
  marks: [
    Plot.cell(datesCal, {
      x: d => d3.utcWeek.count(d3.utcYear(d), d),
      y: d => d.getUTCDay(),
      //fx: d => d.getUTCFullYear(),
      fill: d => Math.floor(unix2doty(d.getTime())) === dotyInput ? "selected" : months[d.getUTCMonth()],
      stroke: d => Math.floor(unix2doty(d.getTime())) === dotyInput ? "darkorange" : "none",
      strokeWidth: 3,
      inset: .5,
    }),
    Plot.text(datesCal, {
      x: d => d3.utcWeek.count(d3.utcYear(d), d),
      y: d => d.getUTCDay(),
      //fx: d => d.getUTCFullYear(),
      text: d => d.getUTCDate() === 7 ? months[d.getUTCMonth()].slice(0, 3) : "",
      y: -1,
      frameAnchor: "left",
      dy: -1,
      monospace: true,
      fontSize: "18px"}),
    Plot.text(datesCal, {
      x: d => d3.utcWeek.count(d3.utcYear(d), d),
      y: d => d.getUTCDay(),
      //fx: d => d.getUTCFullYear(),
      fill: d => Math.floor(unix2doty(d.getTime())) === dotyInput ? "white" : "black",
      //stroke: "white",
      text: d => d.getUTCDate(), //Math.floor(unix2doty(d.getTime())).toString().padStart(3, "0"),
      monospace: true,
      fontSize: "13px"})
  ]
})
```
:::

```{ojs}
//| echo: false
viewof dotyInput = Inputs.range([0, 364 + leapInput], {value: 306, step: 1, label: "Day of the year"});
viewof monthInput = transformInput(
  Inputs.range([1, 12], {step: 1, label: "Month"}),
  {bind: viewof dotyInput, transform: doty2month, invert: month2doty}
);
viewof dotyInput1 = transformInput(
  Inputs.range([-365 - leapInput, -1], {step: 1, label: "Day of the year"}),
  {bind: viewof dotyInput, transform: subN, invert: addN}
);
viewof dotmInput = transformInput(
  Inputs.range([1, 31], {step: 1, label: "Day of the month"}),
  {bind: viewof dotyInput, transform: doty2dotm, invert: (x => Math.floor(( 153 * (
    viewof monthInput.value > 2
    ? viewof monthInput.value - 3
    : viewof monthInput.value + 9) + 2
  ) / 5 + x - 1
))});
viewof leapscrub = Inputs.form([
  Scrubber(numbers, {autoplay: false, alternate: true, delay: 86.4, loopDelay: 864, format: y => "", inputStyle: "display:none;"}),
  Inputs.toggle({label: "Leap year", value: false}),
])
```

[First day of the Gregorian calendar year]{.radiotitle}

```{ojs}
//| echo: false
viewof dotwInput = Inputs.radio([
  "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday",
  ], {value: "Sunday"})
```

There are two rangeüéöÔ∏èinputs labeled as "day of the year" because every doty can be expressed as both a positive and a negative number. The typical range for positive doty values is 0 to [n]{.orange}-1, and negative doty values typically range from -[n]{.orange} to -1, where [n]{.orange} is the number of days in the year. Doty values outside these [bounds](https://en.wikipedia.org/wiki/Upper_and_lower_bounds#:~:text=an%20upper%20bound%20or%20majorant%5B1%5D%20of%20a%20subset%20S%20of%20some%20preordered%20set%20(K%2C%20%E2%89%A4)%20is%20an%20element%20of%20K%20that%20is%20greater%20than%20or%20equal%20to%20every%20element%20of%20S.%5B2%5D%5B3%5D%20Dually%2C%20a%20lower%20bound%20or%20minorant%20of%20S%20is%20defined%20to%20be%20an%20element%20of%20K%20that%20is%20less%20than%20or%20equal%20to%20every%20element%20of%20S) represent days in previous or subsequent years.

The Play‚ñ∂Ô∏èbutton above cyclesüîÑthrough every doty, month, and day of the month in the plots so that each day gets its turn to be highlighted with a redüü•background. The appearance of the bottom plot depends on the [toggle](https://observablehq.com/framework/inputs/toggle#:~:text=choose%20one%20of%20two%20values)‚úÖand [radio](https://observablehq.com/framework/inputs/radio#:~:text=choose%20one%20of%20a%20given%20set%20of%20values)üîòinputs, which determine whether [n]{.orange} is 365 (common year) or 366 (leap year) and the day of the week that starts the year, respectively.

The toggle‚úÖinput shifts 306 dates, [Day 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="March 1"} to [Day 305]{.underline .tool data-bs-toggle="tooltip" data-bs-title="December 31"}, in the Gregorian calendar by one day, but does not change the order of any Dec dates, because [leap day](https://en.wikipedia.org/wiki/February_29#:~:text=intercalary%20date%20added%20periodically) ([Day 365]{.underline .tool data-bs-toggle="tooltip" data-bs-title="February 29"}) is the last day of the Dec leap years and the doty resets to zero at the start of every year. The radioüîòinput shifts every Gregorian calendar date by 1 to 6 days, but has no effect on Decalendar whatsoever.

The current doty, [\${decoDoty}]{.cyan}, combines the current dek, [\${decoDoty.slice(0, 2)}]{.cyan}, and day of the dek, [\${decoDoty[2]}]{.cyan}. Deks are groups of 10 days that are well-aligned with the Dec year. Every Dec year starts on [Day 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="March 1"}, the first day of first dek of the year, Dek 0. Common years end on [Day 364]{.underline .tool data-bs-toggle="tooltip" data-bs-title="February 28"}, exactly halfway through Dek 36, whereas leap years end on the sixth day of Dek 36: [Day 365]{.underline .tool data-bs-toggle="tooltip" data-bs-title="February 29"}.

The last day of the year, [Day -1]{.underline .tool data-bs-toggle="tooltip" data-bs-title="February 28 in common years, February 29 in leap years"} is always followed by [Day 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="March 1"}, regardless of the last 4 or 5 days of Dec 36 that extend past the end of the year. While the doty functions within the bounds of a given year, the day of the era (dote), a continuous count of days since the Dec epoch, provides an unbroken sequence of deks that is analogous to the weeks in the Gregorian calendar.

# Week

Even though Dec uses deks instead of weeks, Dec dates can be modified to include [POSIX](https://en.wikipedia.org/wiki/POSIX#:~:text=a%20family%20of%20standards%20specified%20by%20the%20IEEE%20Computer%20Society%20for%20maintaining%20compatibility%20between%20operating%20systems) [Sunday-based weekday numbers](https://pubs.opengroup.org/onlinepubs/007904875/utilities/date.html#:~:text=weekday%20as%20a%20decimal%20number%20%5B0%2C6%5D%20(0%3Dsunday)). To convert the current Dec date, [\${decoYear}]{.yellow}+[\${decoDoty}]{.cyan}, into the current Dec day of the week (dotw) date, [\${decoYear}]{.yellow}\${dotw0sign}[\${dotw0doty}]{.cyan}+[\${dotw}]{.azul}, we split the current doty, [\${decoDoty}]{.cyan}, into the doty of the first day of the current week, [\${dotw0doty}]{.cyan}, and the current POSIX weekday number: [\${dotw}]{.azul}.

Dec uses [unsimplified](https://en.wikipedia.org/wiki/Simplification#:~:text=the%20process%20of%20replacing%20a%20mathematical%20expression%20by%20an%20equivalent%20one%2C%20that%20is%20simpler) math expressions to display information about a date, such as its dotw, as shown above. All Dec dates can be simplified into [y]{.yellow}, the [decimal](https://en.wikipedia.org/wiki/Decimal#:~:text=denoting%20integer%20and-,non%2Dinteger%20numbers,-.%20It%20is%20the) years that have passed since the Dec [epoch](https://en.wikipedia.org/wiki/Epoch#:~:text=an%20instant%20in%20time%20chosen%20as%20the%20origin%20of%20a%20particular%20calendar%20era) ([Year 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="1 BC"} [Day 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="March 1"} [Dot 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="midnight"}). Storing dates in the form of [y]{.yellow} can be very convenient if we need to be able to see the year associated with each date, but not the doty or dotw.


To convert a Dec date into [y]{.yellow}, we solve the Dec date equation, &LeftFloor;[y]{.yellow}&RightFloor;+[d]{.cyan}&div;[n]{.orange}=[y]{.yellow}, where &LeftFloor;[y]{.yellow}&RightFloor;+[d]{.cyan} is the Dec date, &LeftFloor;[y]{.yellow}&RightFloor; is the year, [d]{.cyan} is the doty, and [n]{.orange} is the number of days in Year &LeftFloor;[y]{.yellow}&RightFloor;. The Dec date equation can be rearranged into the Dec doty equation, [d]{.cyan}=[y]{.yellow}%1&times;[n]{.orange}, which defines [d]{.cyan} as the product of [n]{.orange} and [y]{.yellow}%1, the [decimal part](https://en.wikipedia.org/wiki/Fractional_part#:~:text=the%20excess%20beyond%20that%20number%27s%20integer%20part) of [y]{.yellow} ([y]{.yellow}-&LeftFloor;[y]{.yellow}&RightFloor; or [y]{.yellow} [mod](https://en.wikipedia.org/wiki/Modulo#:~:text=returns%20the%20remainder) 1).

The Dec date equation We can convert the current [y]{.yellow} into the current doty [d]{.cyan} by [flooring](https://en.wikipedia.org/wiki/Floor_and_ceiling_functions#:~:text=the%20greatest%20integer%20less%20than%20or%20equal%20to%20x) the product of the [decimal part](https://en.wikipedia.org/wiki/Fractional_part#:~:text=the%20excess%20beyond%20that%20number%27s%20integer%20part) of [y]{.yellow} and the year length [n]{.orange}: [\${decoDoty}]{.cyan}=&LeftFloor;[\${mod1FracYear}]{.yellow}&times;[\${nDaysInYear}]{.orange}&RightFloor;. Working with the doty independently of the year makes it easier to compare Dec date formats, because most Dec date formats modify the doty without affecting the year.

Instead of the doty [d]{.cyan}, Dec dotw dates display [d]{.cyan}-[w~d~]{.azul}+[w~d~]{.azul}, where [d]{.cyan}-[w~d~]{.azul} is the first doty of the current week and [w~d~]{.azul} is the dotw number associated with the doty [d]{.cyan}. We evaluate the subtraction, but leave the addition unsimplified so we can see [w~d~]{.azul}.

Dec dotw dates can be further modified to include [POSIX week numbers](https://pubs.opengroup.org/onlinepubs/007904875/utilities/date.html#:~:text=week%20of%20the%20year%20(sunday%20as%20the%20first%20day%20of%20the%20week)%20as%20a%20decimal%20number%20%5B00%2C53%5D.%20all%20days%20in%20a%20new%20year%20preceding%20the%20first%20sunday%20shall%20be%20considered%20to%20be%20in%20week%200.). The current week number, \${week}, is the result of adding the middle number in the Dec dotw date, [\${dotw0doty}]{.cyan}, to the Day 0 dotw number, [\${doty0dotw}]{.azul}, and then floor dividing by 7. The current Dec week date, [\${decoYear}]{.yellow}+7&times;[\${week}]{.wheat}+[\${dotw}]{.azul}, shows how we can obtain the sum of the current doty and the Day 0 dotw number: 7&times;[\${week}]{.wheat}+[\${dotw}]{.azul}=[\${decoDoty}]{.cyan}+[\${doty0dotw}]{.azul}.

Dec week dates turn [d]{.cyan}-[w~d~]{.azul} into 7&times;[W]{.wheat}-[w~0~]{.azul}, where [W]{.wheat} is the week number and [w~0~]{.azul} is the dotw number on Day 0. In this case, the subtraction is omitted, because [w~0~]{.azul} is not necessary to identify a date and can be calculated from a given &LeftFloor;[y]{.yellow}&RightFloor;.

While Dec dotw dates provide all of the information needed to identify specific dates and coordinate schedules based on deks or weeks, Dec week dates may be useful for [week-based accounting](https://en.wikipedia.org/wiki/Accounting_period#52%E2%80%9353-week_fiscal_year:~:text=used%20by%20companies%20that%20desire%20that%20their%20fiscal%20year%20always%20end%20on%20the%20same%20day%20of%20the%20week)üßæ.

Following the Dec week date pattern, we can base Dec dates on any fixed-length calendar unit, including the 20-day [dudek](https://en.wiktionary.org/wiki/dudek#Esperanto:~:text=dudek-,twenty,-Polish%5Bedit), 30-day [tridek](https://en.wiktionary.org/wiki/tridek#Esperanto:~:text=tridek-,thirty,-Categories%3A), 40-day [kvardek](https://en.wiktionary.org/wiki/kvardek#Esperanto:~:text=kvardek-,forty,-Categories%3A), or 73-day [sepdektri](https://en.wiktionary.org/wiki/sepdek_tri#Esperanto:~:text=sepdek%20tri-,seventy%2Dthree,-Categories%3A). No other calendar unit can be as convenient as the 10-day [dek](https://en.wiktionary.org/wiki/dek#Esperanto:~:text=dek-,ten%20(10),-Derived%20terms%5B), because our [decimal numeral system](https://en.wikipedia.org/wiki/Decimal#:~:text=system%20for%20denoting%20integer%20and%20non%2Dinteger%20numbers) allows us to naturally combine a dek, [\${decoDoty.slice(0, 2)}]{.cyan}, and a day of the dek (dotd), [\${decoDoty[2]}]{.cyan}, into a doty: [\${decoDoty}]{.cyan}.

# Month

Dec dates can also be modified to display Dec month numbers and [POSIX day of the month (dotm) numbers](https://pubs.opengroup.org/onlinepubs/007904875/utilities/date.html#:~:text=day%20of%20the%20month%20as%20a%20decimal%20number%20%5B01%2C31%5D). The current Dec dotm date is \${decoYear}+\${monthNumber}+\${dotm}. Dec dotm dates represent each month with the last doty of the previous month because POSIX dotm numbers are one-based. For [zero-based](https://en.wikipedia.org/wiki/Zero-based_numbering#:~:text=a%20way%20of%20numbering%20in%20which%20the%20initial%20element%20of%20a%20sequence%20is%20assigned%20the%20index%C2%A00) dotm numbers, we represent each month with its first doty: \${decoYear}+\${monthNumber0}+\${dotm0}.

We can obtain Dec month numbers using only a pair of hands by counting index and ring fingers as 30 days and other fingers as 31 days. For zero-based dotm numbers, we start counting from 0 For one-based dotm numbers, we start counting from -1, as shown in the image below. To spread 12 months across 10 fingers, the first and last fingers each represent 2 months.

{{< include _finger.qmd >}}

# Span

We can combine the dotm and dotw patterns above to create hybrid Dec dates: [\${decoYear}]{.yellow}+[\${monthNumber - dotw}]{.cyan}+[\${dotm}]{.magenta}+[\${dotw}]{.azul}. Essentially, you can modify a Dec date to show whatever numbers you want. All it takes is a little bit of arithmetic! This incredible versatility is possible thanks to the mathematical basis of the notation Dec uses for Dec dates and groups of consecutive Dec dates expressed as Dec spans.

Like [slices](https://en.wikipedia.org/wiki/Array_slicing#1991:_Python:~:text=nums%5B%3A3%5D%20%20%23%20from%20index%200%20(inclusive)%20until%20index%203%20(exclusive)) or [ranges](https://docs.python.org/3/library/stdtypes.html#typesseq-range:~:text=an%20immutable%20sequence%20of%20numbers) in the [Python](https://en.wikipedia.org/wiki/Python_%28programming_language%29#:~:text=a%20high%2Dlevel%2C%20general%2Dpurpose%20programming%20language) programming language, Dec spans are as [right-open](https://en.wikipedia.org/wiki/Interval_(mathematics)#:~:text=open%20if%20it-,contains%20no%20maximum,-%3B%20and%20open%20if) intervals. Dec spans are based on the Dec span equation, M=S+Œî, where Œî is the difference between the [minuend](https://en.wiktionary.org/wiki/minuend#:~:text=A%20number%20or%20quantity%20from%20which%20another%20is%20to%20be%20subtracted) M and the [subtrahend](https://en.wikipedia.org/wiki/Subtraction#:~:text=number%20being%20subtracted) S. If the Dec span equation contains only doty values, [d~M~]{.cyan}=[d~S~]{.cyan}+[d~Œî~]{.cyan}, it represents spans that can apply to any year and are thus called floating, flexible, or **fluid** spans.

The Dec fluid span equation for ${monthName}, [\${currMonth}]{.cyan}=[\${nextMonth}]{.cyan}+[\${diff}]{.cyan}, tells us that ${monthName} starts on Day [\${currMonth}]{.cyan}, ends before Day [\${nextMonth}]{.cyan}, and has [\${diff}]{.cyan} days. We can choose to omit any one of the three parts of any fluid span without changing its meaning. The [d~M~]{.cyan}=[d~S~]{.cyan}, [d~M~]{.cyan}=[d~Œî~]{.cyan}, and =[d~S~]{.cyan}+[d~Œî~]{.cyan} formats of the span for ${monthName} are [\${currMonth}]{.cyan}=[\${nextMonth}]{.cyan}, [\${currMonth}]{.cyan}=[\${diff}]{.cyan}, and =[\${nextMonth}]{.cyan}+[\${diff}]{.cyan}, respectively.

Dec spans that include at least one year are called **fixed** spans because they represent a single set of dates instead of a subset of dates in every year. The short format of fixed spans consists only of the minuend [y~M~]{.yellow}+[d~M~]{.cyan} and subtrahend [y~S~]{.yellow}+[d~S~]{.cyan} Dec dates separated by an equals sign. The full format of fixed spans appends the sum of [y~Œî~]{.yellow} and [d~Œî~]{.cyan}, which are [y~M~]{.yellow}-[y~S~]{.yellow} and [d~M~]{.cyan}-[d~S~]{.cyan}, respectively:

$$\begin{align}
\texttt{\colorbox{yellow}{$y_M$}+\colorbox{cyan}{$d_M$}=\colorbox{yellow}{$y_S$}+\colorbox{cyan}{$d_S$}+\colorbox{yellow}{$y_\Delta$}+\colorbox{cyan}{$d_\Delta$}} \\
\texttt{=\colorbox{yellow}{$y_S$}+\colorbox{cyan}{$d_S$}+\colorbox{yellow}{$y_M$}-\colorbox{yellow}{$y_S$}+\colorbox{cyan}{$d_M$}-\colorbox{cyan}{$d_S$}}
\end{align}$$

Unlike fluid spans, fixed spans cannot omit S without also omitting Œî. In a fixed span, a missing [left-hand side](https://en.wikipedia.org/wiki/Sides_of_an_equation#:~:text=the%20expression%20on%20the%20left%20of%20the%20%22%3D%22) indicates that M is the Day [0]{.cyan} of Year [yS]{.yellow} (M=[yS]{.yellow}+[0]{.cyan}), whereas an empty [right-hand side](https://en.wikipedia.org/wiki/Sides_of_an_equation#:~:text=the%20right%20side%20of%20the%20equation) implies that S is the Day [nM]{.orange} of Year [yM]{.yellow} (S=[yM]{.yellow}+[nM]{.orange}), which means that Œî is the negative doty on Day [dM]{.cyan} (Œî=[dM]{.cyan}-[nM]{.orange}). In short, spans are bound within the given year by default.


There are two main forms of the span equation, fluid: , into the fixed span equation, by including years and dividing each doty by the appropriate [n]{.orange} value. [y~M~]{.yellow}+[d~M~]{.cyan} and [y~S~]{.yellow}+[d~S~]{.cyan} are the minuend and subtrahend Dec dates, [n~M~]{.orange} and [n~S~]{.orange} are the lengths of Year [y~M~]{.yellow} and [y~S~]{.yellow}, [y~Œî~]{.yellow} is [y~M~]{.yellow}-[y~S~]{.yellow}, [d~Œî~]{.cyan} is [d~M~]{.cyan}-[d~S~]{.cyan}, and [n~Œî~]{.orange} is the length of the latest year in the equation, respectively.

The Dec date equation, &LeftFloor;[y]{.yellow}&RightFloor;+[d]{.cyan}&div;[n]{.orange}=[y]{.yellow}, where &LeftFloor;[y]{.yellow}&RightFloor;+[d]{.cyan} is the Dec date, &LeftFloor;[y]{.yellow}&RightFloor; is the year, [d]{.cyan} is the doty, [n]{.orange} is the number of days in Year &LeftFloor;[y]{.yellow}&RightFloor;, and [y]{.yellow} is the [decimal](https://en.wikipedia.org/wiki/Decimal#:~:text=denoting%20integer%20and-,non%2Dinteger%20numbers,-.%20It%20is%20the) years that have passed since the Dec [epoch](https://en.wikipedia.org/wiki/Epoch#:~:text=an%20instant%20in%20time%20chosen%20as%20the%20origin%20of%20a%20particular%20calendar%20era) ([Year 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="1 BC"} [Day 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="March 1"} [Dot 0]{.underline .tool data-bs-toggle="tooltip" data-bs-title="midnight"}), can be rearranged into the Dec doty equation, [d]{.cyan}=[y]{.yellow}%1&times;[n]{.orange}, which defines [d]{.cyan} as the product of [n]{.orange} and the [decimal part](https://en.wikipedia.org/wiki/Fractional_part#:~:text=the%20excess%20beyond%20that%20number%27s%20integer%20part) of [y]{.yellow} ([y]{.yellow}%1, [y]{.yellow}-&LeftFloor;[y]{.yellow}&RightFloor;, or [y]{.yellow} [mod](https://en.wikipedia.org/wiki/Modulo#:~:text=returns%20the%20remainder) 1).

Similarly, [d]{.cyan} in Dec dotm dates is expressed as [d]{.cyan}-[m]{.magenta}+[m]{.magenta}, where [d]{.cyan}-[m]{.magenta} is the Dec month number and [m]{.magenta} is the dotm number. In both cases, we evaluate the subtraction to get [d]{.cyan}-[w~d~]{.azul} or [d]{.cyan}-[m]{.magenta}, but not the addition, so we can see [w~d~]{.azul} or [m]{.magenta}.

Dec week dates turn [d]{.cyan}-[w~d~]{.azul} into 7&times;[W]{.wheat}-[w~0~]{.azul}, where [W]{.wheat} is the week number and [w~0~]{.azul} is the dotw number on Day 0. In this case, the subtraction is omitted, because [w~0~]{.azul} is not necessary to identify a date and can be calculated from a given &LeftFloor;[y]{.yellow}&RightFloor;. Likewise, [n]{.orange} is not included in dates for the same reasons. To find [n]{.orange}, we plug the subsequent year (&LeftFloor;[y]{.yellow}&RightFloor;+1) into the Dec year length equation:

$$\colorbox{orange}{n}=\begin{cases}
  366&{\begin{align}\text{if } (\lfloor \colorbox{yellow}{y}\rfloor+1)\vcenter{\text{ \% }}4=0\\
  \land(\lfloor \colorbox{yellow}{y}\rfloor+1)\vcenter{\text{ \% }}100\neq0\\
  \lor(\lfloor \colorbox{yellow}{y}\rfloor+1)\vcenter{\text{ \% }}400=0\end{align}}\\\\
  365&{\text{otherwise.}}\end{cases}$$

In the equation above, $\vcenter{\text\%}$ is the [modulo](https://en.wikipedia.org/wiki/Modulo#:~:text=returns%20the%20remainder) operator, $\land$ is the logical [conjunction](https://en.wikipedia.org/wiki/Logical_conjunction) operator (and), and $\lor$ is the logical [disjunction](https://en.wikipedia.org/wiki/Logical_disjunction) operator (or). According to this equation, [n]{.orange} has only 2 possible values, 366 if Year &LeftFloor;[y]{.yellow}&RightFloor;+1 is a [Gregorian calendar](https://en.wikipedia.org/wiki/Gregorian_calendar#:~:text=the%20calendar%20used%20in%20most%20parts%20of%20the%20world) [leap year](https://en.wikipedia.org/wiki/Leap_year#:~:text=Every%20year%20that%20is%20exactly%20divisible%20by%20four%20is%20a%20leap%20year%2C%20except%20for%20years%20that%20are%20exactly%20divisible%20by%20100%2C%20but%20these%20centurial%20years%20are%20leap%20years%20if%20they%20are%20exactly%20divisible%20by%20400) and 365 if Year &LeftFloor;[y]{.yellow}&RightFloor;+1 is a Gregorian calendar [common year](https://en.wikipedia.org/wiki/Common_year#:~:text=a%20calendar%20year%20with%20365%20days), and remains constant for 366, 1095, or 2920 days.

Apart from its role in the Dec date and doty equations, [n]{.orange} is needed to convert between [year]{.yellow}+[day]{.cyan} and [year]{.yellow}-[day]{.pink} Dec dates. The [year]{.yellow}-[day]{.pink} version of the Dec date equation is &LeftFloor;[y]{.yellow}&RightFloor;+1+([d]{.cyan}-[n]{.orange})&div;[n]{.orange}=[y]{.yellow}. In essence, [d]{.cyan}-[n]{.orange} is a ["T-minus" countdown](https://en.wikipedia.org/wiki/Countdown#:~:text=backward%20counting%20to%20indicate%20the%20time%20remaining%20before%20an%20event) of the days until the start of Year &LeftFloor;[y]{.yellow}&RightFloor;+1. The current [year]{.yellow}-[day]{.pink} date, [\${nextYear}]{.yellow}-[\${Tminus}]{.pink}, tells us that Year [\${nextYear}]{.yellow} will begin in [\${Tminus}]{.pink} days.

# Index

The difference between [d]{.cyan} and [d]{.cyan}-[n]{.orange} can also be explained in terms of computer programming. If we think of years as [arrays](https://en.wikipedia.org/wiki/Array_(data_structure)#Element_identifier_and_addressing_formulas:~:text=a%20data%20structure%20consisting%20of%20a%20collection%20of%20elements%20(values%20or%20variables)%2C%20of%20same%20memory%20size%2C%20each%20identified%20by%20at%20least%20one%20array%20index), [d]{.cyan} and [d]{.cyan}-[n]{.orange} are like array [indexes](https://en.wikipedia.org/wiki/Array_(data_structure)#Element_identifier_and_addressing_formulas:~:text=individual%20objects%20are%20selected%20by%20an%20index) that can be used to identify array elements or combine them into groups via [slicing](https://en.wikipedia.org/wiki/Array_slicing#:~:text=an%20operation%20that%20extracts%20a%20subset%20of%20elements%20from%20an%20array). In this analogy, [n]{.orange} is the number of elements in the array, [d]{.cyan} is a [positive index](https://en.wikipedia.org/wiki/Zero-based_numbering#:~:text=a%20way%20of%20numbering%20in%20which%20the%20initial%20element%20of%20a%20sequence%20is%20assigned%20the%20index%C2%A00), and [d]{.cyan}-[n]{.orange} is a [negative index](https://en.wikipedia.org/wiki/Array_slicing#:~:text=specify%20an%20offset%20from%20the%20end%20of%20the%20array).

The array analogy can be extended beyond Dec dates to Dec times if indexes can be [floating-point](https://en.wikipedia.org/wiki/Floating-point_arithmetic#:~:text=an%20integer%20with%20a%20fixed%20precision%2C%20called%20the%20significand%2C%20scaled%20by%20an%20integer%20exponent%20of%20a%20fixed%20base) [decimal numbers](https://en.wikipedia.org/wiki/Decimal#Decimal_notation:~:text=a%20number%20in%20the%20decimal%20numeral%20system) (floats) in addition to integers. In Dec, the decimal part of a doty represents represents a time of day. While the Python programming language [requires indexes to be integers](https://docs.python.org/3/library/exceptions.html#IndexError:~:text=if%20an%20index%20is%20not%20an%20integer%2C%20TypeError%20is%20raised), the [Pandas](https://en.wikipedia.org/wiki/Pandas_(software)#:~:text=a%20software%20library%20written%20for%20the%20Python%20programming%20language%20for%20data%20manipulation%20and%20analysis) Python [library](https://en.wikipedia.org/wiki/Library_(computing)#:~:text=a%20collection%20of%20resources%20that%20is%20leveraged%20during%20software%20development) permits [indexing with a date and a time](https://pandas.pydata.org/docs/user_guide/timeseries.html#slice-vs-exact-match:~:text=series_minute%5B%22-,2011%2D12%2D31%2023%3A59,-%22%5D%0AOut).

The combination of a Dec date and a Dec time is a called a snap. A Dec date is essentially a Dec snap that has been [truncated](https://en.wikipedia.org/wiki/Truncation#:~:text=limiting%20the%20number%20of%20digits%20right%20of%20the%20decimal%20point) until the time is no longer specified. Truncation of both positive and negative doty values in Dec snaps can be accomplished with the [floor function](https://en.wikipedia.org/wiki/Floor_and_ceiling_functions#:~:text=the%20greatest%20integer%20less%20than%20or%20equal%20to%20x): &LeftFloor;[d]{.cyan}&RightFloor;. Unlike Pandas [string](https://en.wikipedia.org/wiki/String_(computer_science)#:~:text=a%20sequence%20of%20characters) indexes, Dec snaps cannot be shortened to a [year and a month](https://pandas.pydata.org/docs/user_guide/timeseries.html#partial-string-indexing:~:text=the%20year%20or-,year%20and%20month,-as%20strings%3A).

The subsequent articles on my site build on this article to further describe Dec [times](/dec/time), [snaps](/dec/span), and [spans](/dec/span). A basic understanding of the Dec [year]{.yellow}+[day]{.cyan} date format is enough to understand the examples in the [filter](/quarto/filter) and [script](/quarto/script) articles in the [Quarto section](/quarto) of my site, but it might be helpful to read my [Dec time article](/dec/time) before moving on to my Quarto [include article](/quarto/include).

Thank you for your interest in Dec. You will find citation information for this article below. Please note that this article does not describe the algorithms underlying Dec dates and cite the original source of the algorithms as [Hinnant, Howard](https://howardhinnant.github.io). [2021+184]{.underline .tool data-bs-toggle="tooltip" data-bs-title="2021-09-01"}. ‚Äú`chrono`-Compatible Low-Level Date Algorithms.‚Äù [\${decoYear}]{.yellow}+[\${decoDoty}]{.cyan}. <https://howardhinnant.github.io/date_algorithms.html>.

```{ojs}
//| echo: false
//| output: false
unix = {
  while(true) {
    yield Date.now();
  }
}
// http://howardhinnant.github.io/date_algorithms.html#civil_from_days
function unix2dote(unix, zone, offset = 719468) {
  return [(unix ?? Date.now()) / 86400000 + (
    zone = zone ?? -Math.round(
      (new Date).getTimezoneOffset() / 144)
    ) / 10 + offset, zone]
}
function dote2date(dote, zone = 0) {
  const cote = Math.floor((
      dote >= 0 ? dote
      : dote - 146096
    ) / 146097),
  dotc = dote - cote * 146097,
  yotc = Math.floor((dotc
    - Math.floor(dotc / 1460)
    + Math.floor(dotc / 36524)
    - Math.floor(dotc / 146096)
  ) / 365);
  return [
    yotc + cote * 400,
    dotc - (yotc * 365
      + Math.floor(yotc / 4)
      - Math.floor(yotc / 100)
  ), zone]}
function doty2deco0(year = 1969, doty = 306, zone = 0) {
  return `${year.toString().padStart(4, "0")}+${Math.floor(doty).toString().padStart(3, "0")}${String(doty % 1 * 10).slice(0, 6)}-${zone}`
}
dz = unix2dote(unix)
ydz = dote2date(...dz)
deco = doty2deco0(...ydz)
function year2leap(year = 1970) {
  return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}
function dote2dotw(d = 719468) {
  return d >= -3 ? (d + 3) % 7 : (d + 4) % 7 + 6
}
decoYear = deco.slice(0, 4)
nextYear = parseInt(decoYear) + 1
decoDoty = deco.slice(5, 8)
dotw = Math.floor(dote2dotw(dz[0]))
week = Math.floor((ydz[1] + doty0dotw) / 7)
dotm = doty2dotm(Math.floor(ydz[1]))
dotm0 = String(dotm - 1).padStart(2, "0")
dotm1 = dotm.toString().padStart(2, "0")
monthNumber = Math.floor(ydz[1] - dotm)
monthNumber0 = String(monthNumber + 1).padStart(3, "0")
monthNumber1 = monthNumber.toString().padStart(3, "0")
dotw0doty = Math.floor(ydz[1]) - dotw
doty0dote = date2dote(ydz[0], 0, ydz[2])
doty0dotw = dote2dotw(...doty0dote)
dotw0sign = dotw0doty < 0 ? "-" : "+"
nDaysInYear = 365 + year2leap(ydz[0] + 1)
Tminus = nDaysInYear - decoDoty
fracYear = ydz[0] + ydz[1] / nDaysInYear
fullfracYear = (fracYear).toFixed(4)
mod1FracYear = (fracYear % 1).toFixed(4)
months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
monthNums = ["305", "336", "", "31", "61", "92", "122", "153", "184", "214", "245", "275"];
today = new Date()
monthName = today.toLocaleString('default', { month: 'long' });
monthNumJS = today.getMonth();
currMonth = monthNums[monthNumJS]
nextMonth = monthNums[(monthNumJS + 1) % 12]
dekStart = Math.floor(decoDoty / 10) * 10
diff = parseInt(currMonth || 0) - parseInt(nextMonth || nDaysInYear)
  //currMonth === "" ? 0 : parseInt(currMonth) - nextMonth === "" ? nDaysInYear : parseInt(nextMonth)
// https://observablehq.com/@juang1744/transform-input/1
transformInput = function(target, {bind: source, transform = identity, involutory = false, invert = involutory ? transform : inverse(transform)} = {}){
  if (source === undefined) {
    source = target;
    target = html`<div>${source}</div>`;
  }
  function sourceInputHandler() {
    target.removeEventListener("input", targetInputHandler);
    setTransform(target).to(transform(source.value)).andDispatchEvent();
    target.addEventListener("input", targetInputHandler);
  }
  function targetInputHandler() {
    source.removeEventListener("input", sourceInputHandler);
    setTransform(source).to(invert(target.value)).andDispatchEvent();
    source.addEventListener("input", sourceInputHandler);
  }
  source.addEventListener("input", sourceInputHandler);
  target.addEventListener("input", targetInputHandler);
  invalidation.then(() => {
    source.removeEventListener("input", sourceInputHandler);
    target.removeEventListener("input", targetInputHandler);
  });
  sourceInputHandler();
  return target;
}
setTransform = (input) => ({to: (value) => (input.value = value, {andDispatchEvent: (event = new Event("input")) => input.dispatchEvent(event)})});
function inverse(f) {
  switch (f) {
    case identity:  return identity;
    case Math.sqrt: return square;
    case Math.log:  return Math.exp;
    case Math.exp:  return Math.log;
    default:        return (x => solve(f, x, x));
  }
  function solve(f, y, x = 0) {
    const dx = 1e-6;
    let steps = 100, deltax, fx, dfx;
    do {
      fx = f(x)
      dfx = (f(x + dx) - fx) || dx;
      deltax = dx * (fx - y)/dfx
      x -= deltax;
    } while (Math.abs(deltax) > dx && --steps > 0);
    return steps === 0 ? NaN : x;
  }
function square(x) {
    return x * x;
  }
}
function identity(x) {
  return x;
}
function doty2month(doty = 0) {
    const m = Math.floor((5 * doty + 2) / 153);
    return Math.floor(m < 10 ? m + 3 : m - 9);
}
function month2doty(month = 1) {
    return Math.floor(
        (153 * (month > 2 ? month - 3 : month + 9) + 2) / 5
)}
function doty2dotm(doty = 0) {
    const m = Math.floor((5 * doty + 2) / 153);
    return doty - Math.floor((153 * m + 2) / 5) + 1;
}
numbers = Array.from({length: 366}, (_, i) => i)
set(viewof dotyInput, leapscrub[0])
// https://observablehq.com/@observablehq/synchronized-inputs
function set(input, value) {
  input.value = value;
  input.dispatchEvent(new Event("input", {bubbles: true}));
}
// https://observablehq.com/@mbostock/scrubber
function Scrubber(values, {
  format = value => value,
  initial = 0,
  direction = 1,
  delay = null,
  autoplay = true,
  loop = true,
  loopDelay = null,
  alternate = false,
  inputStyle = ""
} = {}) {
  values = Array.from(values);
  const form = html`<form style="font: 18px var(--monospace); font-variant-numeric: tabular-nums; display: flex; height: 33px; align-items: center;">
  <button name=b type=button style="margin-right: 0.4em; width: 5em;"></button>
  <label style="display: flex; align-items: center;">
    <input name=i type=range min=0 max=${values.length - 1} value=${initial} step=1 style=${inputStyle}>
    <output name=o style="margin-left: 0.4em;"></output>
  </label>
</form>`;
  let frame = null;
  let timer = null;
  let interval = null;
  function start() {
    form.b.textContent = "Stop";
    if (delay === null) frame = requestAnimationFrame(tick);
    else interval = setInterval(tick, delay);
  }
  function stop() {
    form.b.textContent = "Play";
    if (frame !== null) cancelAnimationFrame(frame), frame = null;
    if (timer !== null) clearTimeout(timer), timer = null;
    if (interval !== null) clearInterval(interval), interval = null;
  }
  function running() {
    return frame !== null || timer !== null || interval !== null;
  }
  function tick() {
    if (form.i.valueAsNumber === (direction > 0 ? values.length - 1 : direction < 0 ? 0 : NaN)) {
      if (!loop) return stop();
      if (alternate) direction = -direction;
      if (loopDelay !== null) {
        if (frame !== null) cancelAnimationFrame(frame), frame = null;
        if (interval !== null) clearInterval(interval), interval = null;
        timer = setTimeout(() => (step(), start()), loopDelay);
        return;
      }
    }
    if (delay === null) frame = requestAnimationFrame(tick);
    step();
  }
  function step() {
    form.i.valueAsNumber = (form.i.valueAsNumber + direction + values.length) % values.length;
    form.i.dispatchEvent(new CustomEvent("input", {bubbles: true}));
  }
  form.i.oninput = event => {
    if (event && event.isTrusted && running()) stop();
    form.value = values[form.i.valueAsNumber];
    form.o.value = format(form.value, form.i.valueAsNumber, values);
  };
  form.b.onclick = () => {
    if (running()) return stop();
    direction = alternate && form.i.valueAsNumber === values.length - 1 ? -1 : 1;
    form.i.valueAsNumber = (form.i.valueAsNumber + direction) % values.length;
    form.i.dispatchEvent(new CustomEvent("input", {bubbles: true}));
    start();
  };
  form.i.oninput();
  if (autoplay) start();
  else stop();
  Inputs.disposal(form).then(stop);
  return form;
}
calYear = !leapInput && dotwInput == "Monday" ? 6 : !leapInput && dotwInput == "Tuesday" ? 7 : !leapInput && dotwInput == "Wednesday" ? 2 : !leapInput && dotwInput == "Thursday" ? 3 : !leapInput && dotwInput == "Friday" ? 9 : !leapInput && dotwInput == "Saturday" ? 10 : !leapInput && dotwInput == "Sunday" ? 11 : leapInput && dotwInput == "Monday" ? 12 : leapInput && dotwInput == "Tuesday" ? 24 : leapInput && dotwInput == "Wednesday" ? 8 : leapInput && dotwInput == "Thursday" ? 20 : leapInput && dotwInput == "Friday" ? 4 : leapInput && dotwInput == "Saturday" ? 16 : leapInput && dotwInput == "Sunday" ? 28 : 0;
datesCal = d3.utcDays(new Date(calYear, 0, 0), new Date(calYear, 12, 0));
function unix2doty(unix) {
  const dote = (
    unix ?? Date.now()
  ) / 86400000 + 719468,
    cote = Math.floor((
      dote >= 0 ? dote
      : dote - 146096
    ) / 146097),
  dotc = dote - cote * 146097,
  yotc = Math.floor((dotc
    - Math.floor(dotc / 1460)
    + Math.floor(dotc / 36524)
    - Math.floor(dotc / 146096)
  ) / 365);
  return dotc - (yotc * 365
      + Math.floor(yotc / 4)
      - Math.floor(yotc / 100)
  )}
function date2dote(year = 1969, doty = 306, zone = 0) {
    const cote = Math.floor((year >= 0 ? year : year - 399) / 400),
      yote = year - cote * 400;
    return [cote * 146097 + yote * 365 + Math.floor(yote / 4) - Math.floor(yote / 100) + doty, zone]
}
function doty2deco(yearDoty = [1969, 306], zone = 0) {
    const yd = dote2date(...date2dote(yearDoty[0], Math.floor(yearDoty[1]), zone));
    return `${yd[0].toString().padStart(4, "0")}+${yd[1].toString().padStart(3, "0")}${
        yearDoty[1].toString().includes(".") ? "." + (
            (yearDoty[1] > 0) ? (yearDoty[1] - zone).toString().split(".").pop()
            : [...(yearDoty[1] - zone).toString().split(".").pop()].map(
                (e, i, a) => (i + 1 === a.length) ? 10 - e : 9 - e
            ).join("")
        ) : ""
    }`
}
function deco2doty(timestamp = "1969+306.00000Z") {
    const arr = timestamp.toString().split(/(?=[+-]|[a-zA-Z])/, 3);
    switch (arr.length) {
        case 1: return [unix2doty(Date.now())[0], parseFloat(arr[0]), 0];
        case 2: return (/^[a-zA-Z]+$/.test(arr[1]))
            ? [unix2doty(Date.now())[0], parseFloat(arr[0]), zone2hour(arr[1]) / 24]
            : [parseFloat(arr[0]), parseFloat(arr[1]), 0];
    };
    return [parseFloat(arr[0]), parseFloat(arr[1]), /^[a-zA-Z]+$/.test(arr[2])
        ? zone2hour(arr[2]) / 24
        : parseFloat(arr[2].replace(/([+-])/, "$1\."))];
}
function zone2hour(zone = "Z") {
    return (zone = zone.toUpperCase()) == "Z" ? 0
        : zone > "@" && zone < "J" ? zone.charCodeAt() - 64
        : zone > "J" && zone < "N" ? zone.charCodeAt() - 65
        : zone < "Z" && zone > "M" ? -(zone.charCodeAt() - 77)
        : zone;
}
function doty2unix(year = 1969, doty = 306, zone = 0) {
    return (date2dote(year, doty, zone) - 719468) * 86400000;
}
function doty2isoc(yd) {
    return new Date(doty2unix(...yd))
}
function doty2greg(doty = 306) {
    const m = Math.floor((5 * doty + 2) / 153);
    return [
      Math.floor(m < 10 ? m + 3 : m - 9),
      Math.floor(doty - (153 * m + 2) / 5 + 2)
    ];
}
function greg2doty(month = 1, day = 1) {
    return Math.floor(
        (153 * (month > 2 ? month - 3 : month + 9) + 2) / 5 + day - 1
)}
function greg2year(year = 1970, month = 1) { return year - (month < 3) }
function isoc2doty(isoc) {
  return [greg2year(isoc.getFullYear(), isoc.getUTCMonth() + 1), greg2doty(isoc.getUTCMonth() + 1, isoc.getUTCDate())];
}
leapInput = leapscrub[1]
function addN(d) { return d + 365 + leapInput }
function subN(d) { return d - 365 - leapInput }
dates = d3.utcDays(new Date(1999, 2, 0), new Date(2000, 1, 28 + leapInput));
```

```{=html}
<style>
h6.relative.anchored {
  margin-top: -25px;
  margin-bottom: -2px;
}
<!-- .calplot { -->
<!--   margin-top: -15px; -->
<!--   margin-bottom: -15px; -->
<!-- } -->
#decalendar > g.cluster-label {
  transform: translate(305px, 50px) !important;
}
span.cal-swatch {
  font-size: 14px !important;
}
form.oi-3a86ea-checkbox {
  max-width: 700px;
}
div.cell:has(form.oi-3a86ea-toggle) {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
}
div.observablehq > div:has(form.oi-3a86ea-toggle) {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
}
form.oi-3a86ea-toggle {
  max-width: 100% !important;
  --label-width: 100px;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
}
form.oi-3a86ea {
  --input-width: 200px;
  padding-right: 9px;
}
form.oi-3a86ea-toggle > label {
  width: 75px;
}
input.oi-3a86ea-input[type="checkbox"] {
  margin: 6px 0px 0px 0px;
}
div > form > label {
  --label-width: 140px;
}
input[type="radio"], input[type="checkbox"] {
  margin: 2px 0px 0px 0px;
}
p:has(.radiotitle) {
  margin-top: -8px !important;
  margin-bottom: -4px;
  text-align: center;
}
svg#finger {
  max-width: 760px;
}
h4.anchored {
  margin: 8px 0px 8px 0px;
}
</style>
```
