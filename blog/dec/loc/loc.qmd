---
title: 'Declock'
author: 'Martin Laptev'
format: html
echo: false
observable: 'https://observablehq.com/@dec/loc'
---

```{ojs}
md`# Declock`
```

```{ojs}
md`This notebook discusses Declock, a decimal timekeeping system that records time as the&nbsp;[fractional days](https://en.wikipedia.org/wiki/Decimal_time#Fractional_days:~:text=The%20time%20of%20day%20is%20sometimes%20represented%20as%20a%20decimal%20fraction%20of%20a%20day%20in%20science%20and%20computers.)&nbsp;since midnight. Declock is part of Dec, a [measurement system](https://en.wikipedia.org/wiki/System_of_units_of_measurement#:~:text=a%20collection%20of%20units%20of%20measurement%20and%20rules%20relating%20them%20to%20each%20other) that [I](https://maptv.github.io) created to measureâ³time,ðŸ“position,ðŸ§­orientation,ðŸ“angles, andðŸ”„cycles in [turns](https://en.wikipedia.org/wiki/Turn_%28angle%29#:~:text=a%20unit%20of%20plane%20angle%20measurement%20equal%20to%202%CF%80%C2%A0radians%2C%20360%C2%A0degrees) ([${tex`\tau`}](https://en.wikipedia.org/wiki/Turn_%28angle%29#:~:text=the%20Greek%20letter,to%20one%20turn)) instead of months, weeks, hours, minutes, seconds, and degrees. For time measurement, Dec uses days and years, which are turns of a [celestial body](https://en.wikipedia.org/wiki/Astronomical_object#:~:text=a%20single%2C%20tightly%20bound%2C%20contiguous%20entity) on [its axis](https://en.wikipedia.org/wiki/Axial_tilt#:~:text=the%20imaginary%20line%20that%20passes%20through%20both%20the%20north%20pole%20and%20south%20pole) and around [the point it orbits](https://en.wikipedia.org/wiki/Barycenter_%28astronomy%29#:~:text=the%20point%20about%20which%20the%20bodies%20orbit), respectively.`
```

```{ojs}
md`Dec uses [metric prefixes](https://en.wikipedia.org/wiki/Metric_prefix#:~:text=a%20unit%20prefix%20that%20precedes%20a%20basic%20unit%20of%20measure%20to%20indicate%20a%20multiple%20or%20submultiple%20of%20the%20unit) to create [submultiples](https://en.wikipedia.org/wiki/Multiple_%28mathematics%29#Submultiple:~:text=of%20%22a%20being-,a%20unit%20fraction,-of%20b%22%20) of turns. The clock and bar chart below show the [decidays](https://en.wikipedia.org/wiki/Decimal_time#:~:text=dividing%20the%20day%20into%2010%20decidays) (top bar and shortest clock hand), millidays (middle bar and longest clock hand), and centimillidays (bottom bar and thinnest clock hand) of the current time at the longitude of the red circle on the [solar terminator](https://en.wikipedia.org/wiki/Terminator_%28solar%29#:~:text=a%20moving%20line%20that%20divides%20the%20daylit%20side%20and%20the%20dark%20night%20side%20of%20a%20planetary%20body) map beneath the clock. Drag the red circle across the time zone borders (vertical gray lines) on the map to see how changing time zones affects the time.`
```

```{ojs}
// https://observablehq.com/@fheyen/barchart-clock
barChart = {
const W = width > 1250 ? width * 2 / 3 : width > 1150 ? width * 3 / 4 : width > 1050 ? width * 4 / 5 : width > 950 ? width * 5 / 6 : width > 850 ? width : width > 750 ? width * 1.02 : width > 650 ? width * 1.06 : width > 550 ? width * 1.1 : width > 450 ? width * 1.14 : width * 1.18;
  const H = 88;
  const barX = 1;
  const firstBarY = 1;
  const svg = d3
    .create("svg")
    .attr("width", W)
    .attr("viewBox", [0, 0, W, H]);
  const xRange = [0, W - 100];
  const scaleDD = d3.scaleLinear()
    .domain([0, 10])
    .range(xRange);
  const scaleMandB = d3.scaleLinear()
    .domain([0, 100])
    .range(xRange);
  // const scaleDek = d3.scaleLinear()
  //  .domain([0, 37])
  //  .range(xRange);
  // Background bars to show where 100% lies
  svg.selectAll('.background')
    .data([
      // 'dek', 'dotd',
      'dd', "mils", 'beats'])
    .enter()
    .append('rect')
    .attr('class', 'background timeBar')
    .attr('width', W-100)
    .attr('y', (d,i)=>i*30+firstBarY)
  // // Dek/Dotd
  // svg
  //   .append('rect')
  //   .attr('class', 'timeBar')
  //   .attr('y', firstBarY)
  //   .attr('width', d => scaleDek(Number(dotyDek)+Number(dotyDotd)/10+Number(barCents)/1000))
  // svg
  //   .append('rect')
  //   .attr('class', 'timeBarFull')
  //   .attr('y', firstBarY)
  //   .attr('width', d => scaleDek(dotyDek))
  // svg
  //   .append('rect')
  //   .attr('class', 'timeBar')
  //   .attr('y', firstBarY+30)
  //   .attr('width', d => scaleM(Number(dotyDotd)+Number(barCents)/100+Number(barMils)/1000))
  // svg
  //   .append('rect')
  //   .attr('class', 'timeBarFull')
  //   .attr('y', firstBarY+30)
  //   .attr('width', d => scaleM(dotyDotd))
  // svg.selectAll('.tickDek')
  //   .data(d3.range(width > 500 ? 4: 6, 37))
  //   .enter()
  //   .append('rect')
  //   .attr('class', 'tickDek')
  //   .attr('x', d=>scaleDek(d)+barX)
  //   .attr('y', firstBarY)
  //   .attr('height', d=>d%(width > 500 ? 2 : 3)===0? 6:4)
  // Cent ticks
  // svg.selectAll('.tickDotd')
  //   .data(d3.range(width > 500 ? 1: 2, 10))
  //   .enter()
  //   .append('rect')
  //   .attr('class', 'tickDotd')
  //   .attr('x', d=>scaleM(d)+barX)
  //   .attr('y', firstBarY+49)
  //   .attr('height', 6)
  // svg.selectAll('.tickLabel')
  //   .data(d3.range(width > 500 ? 4: 6, width > 500 ? 37: 35, width > 500 ? 2: 3))
  //   .enter()
  //   .append('text')
  //   .attr('class', 'tickLabel')
  //   .attr('x', d=>scaleDek(d)+barX+.5)
  //   .attr('y', firstBarY+22)
  //   .text(d=>d)
  // Beats
  svg
    .append('rect')
    .attr('class', 'timeBar')
    .attr('y', firstBarY+60)
    .attr('width', d => scaleMandB(Number(barBeats)+Number(barMb)/1000))
  svg
    .append('rect')
    .attr('class', 'timeBarFull')
    .attr('y', firstBarY+60)
    .attr('width', d => scaleMandB(barBeats))
  // Cents/Mils
  svg
    .append('rect')
    .attr('class', 'timeBar')
    .attr('y', firstBarY)
    .attr('width', d => scaleDD(Number(barDD)+Number(barMils)/100+Number(barBeats)/10000+Number(barMb)/10000000))
  svg
    .append('rect')
    .attr('class', 'timeBarFull')
    .attr('y', firstBarY)
    .attr('width', d => scaleDD(barDD))
  svg
    .append('rect')
    .attr('class', 'timeBar')
    .attr('y', firstBarY+30)
    .attr('width', d => scaleMandB(Number(barMils)/10+Number(barBeats)/1000))
  svg
    .append('rect')
    .attr('class', 'timeBarFull')
    .attr('y', firstBarY+30)
    .attr('width', d => scaleMandB(barMils))
  // Cent ticks
  svg.selectAll('.tickC')
    .data(d3.range(width > 500 ? 10 : 10, 100))
    .enter()
    .append('rect')
    .attr('class', 'tickC')
    .attr('x', d=>scaleDD(d/10)+barX)
    .attr('y', firstBarY+30)
    .attr('height', d=>d%2===0? 8:5)
  svg.selectAll('.tickB1')
    .data(d3.range(width > 500 ? 10 : 10, 100))
    .enter()
    .append('rect')
    .attr('class', 'tickB1')
    .attr('x', d=>scaleDD(d/10)+barX)
    .attr('y', d=>d%2===0? firstBarY+77:firstBarY+80)
    .attr('height', d=>d%2===0? 8:5)
  svg.selectAll('.tickC1')
    .data(d3.range(width > 500 ? 10 : 10, 100))
    .enter()
    .append('rect')
    .attr('class', 'tickC1')
    .attr('x', d=>scaleDD(d/10)+barX)
    .attr('y', d=>d%2===0? firstBarY+47:firstBarY+50)
    .attr('height', d=>d%2===0? 8:5)
  // Mil ticks
  svg.selectAll('.tickM')
    .data(d3.range(width > 500 ? 1 : 1, 10))
    .enter()
    .append('rect')
    .attr('class', 'tickM')
    .attr('x', d=>scaleDD(d)+barX)
    .attr('y', firstBarY+20)
    .attr('height', 6)
  // svg.selectAll('.tickM1')
  //   .data(d3.range(width > 500 ? 1 : 2, 10))
  //   .enter()
  //   .append('rect')
  //   .attr('class', 'tickM1')
  //   .attr('x', d=>scaleM(d)+barX)
  //   .attr('y', firstBarY+32.5)
  //   .attr('height', 2.5)
  svg.selectAll('.tickLabel1')
    .data(d3.range(width > 500 ? 1 : 1, 10))
    .enter()
    .append('text')
    .attr('class', 'tickLabel1')
    .attr('x', d=>scaleDD(d)+barX+.5)
    .attr('y', firstBarY+18)
    .text(d=>d)
  // svg.selectAll('.tickLabel2')
  //   .data(d3.range(width > 500 ? 1 : 2, 10))
  //   .enter()
  //   .append('text')
  //   .attr('class', 'tickLabel2')
  //   .attr('x', d=>scaleM(d)+barX+.5)
  //   .attr('y', firstBarY+112)
  //   .text(d=>d)
  // Cent ticks
  svg.selectAll('.tickC2')
    .data(d3.range(width > 500 ? 10 : 10, 100))
    .enter()
    .append('rect')
    .attr('class', 'tickC2')
    .attr('x', d=>scaleDD(d/10)+barX)
    .attr('y', firstBarY+10)
    .attr('height', d=>d%2===0? 9:6)
  // Beat ticks
  svg.selectAll('.tickB')
    .data(d3.range(width > 500 ? 10 : 10, 100))
    .enter()
    .append('rect')
    .attr('class', 'tickB')
    .attr('x', d=>scaleDD(d/10)+barX)
    .attr('y', firstBarY+60)
    .attr('height', d=>d%2===0? 9:6)
  // Labels
  svg.selectAll('.timeLabel')
    .data([
      // `${dotyDek}æ—¬`, `${dotyDotd}æ—¥`,
      `${barDD}`, `${barMils}`, `${barBeats}`])
    .enter()
    .append('text')
    .attr('class', 'timeLabel')
    .attr('x', barX+2)
    .attr('y', (d,i)=>i*30+firstBarY+20)
    .text(d=>d);
  svg.attr("id", "barClock");
  return svg.node();
}
```

```{ojs}
// https://observablehq.com/@d3/simple-clock
// https://observablehq.com/@drio/lets-build-an-analog-clock
clock = {
  const clockRadius = 200,
    margin = 50,
    w = (clockRadius + margin) * 2,
    h = (clockRadius + margin) * 2,
    hourHandLength = (2 * clockRadius) / 3,
    minuteHandLength = clockRadius,
    secondHandLength = clockRadius - 12,
    secondHandBalance = 30,
    secondTickStart = clockRadius,
    secondTickLength = -10,
    hourTickStart = clockRadius,
    hourTickLength = -18,
    secondLabelRadius = clockRadius + 16,
    secondLabelYOffset = 5,
    hourLabelRadius = clockRadius - 40,
    hourLabelYOffset = 7,
    radians = Math.PI / 180;

  const ten = d3
    .scaleLinear()
    .range([0, 360])
    .domain([0, 10]);

  const sto = d3
    .scaleLinear()
    .range([0, 360])
    .domain([0, 100]);

  const handData = [
    {
      type: "hour",
      value: 0,
      length: -hourHandLength,
      scale: ten
    },
    {
      type: "minute",
      value: 0,
      length: -minuteHandLength,
      scale: sto
    },
    {
      type: "second",
      value: 0,
      length: -secondHandLength,
      scale: sto,
      balance: secondHandBalance
    }
  ];

  function drawClock() {
    // create all the clock elements
    updateData(); //draw them in the correct starting position
    const face = svg
      .append("g")
      .attr("id", "clock-face")
      .attr("transform", `translate(${[w / 2, h / 2]})`);

    // add marks for seconds
    face
      .selectAll(".second-tick")
      .data(d3.range(0, 100))
      .enter()
      .append("line")
      .attr("class", "second-tick")
      .attr("x1", 0)
      .attr("x2", 0)
      .attr("y1", secondTickStart)
      .attr("y2", secondTickStart + secondTickLength)
      .attr("transform", d => `rotate(${sto(d)})`);

    // and labels...
    face
      .selectAll(".second-label")
      .data(d3.range(0, 100, 5))
      .enter()
      .append("text")
      .attr("class", "second-label")
      .attr("text-anchor", "middle")
      .attr("x", d => secondLabelRadius * Math.sin(sto(d) * radians))
      .attr(
        "y",
        d =>
          -secondLabelRadius * Math.cos(sto(d) * radians) + secondLabelYOffset
      )
      .text(d => d);

    // ... and hours
    face
      .selectAll(".hour-tick")
      .data(d3.range(0, 10, 1))
      .enter()
      .append("line")
      .attr("class", "hour-tick")
      .attr("x1", 0)
      .attr("x2", 0)
      .attr("y1", hourTickStart)
      .attr("y2", hourTickStart + hourTickLength)
      .attr("transform", d => `rotate(${ten(d)})`);

    face
      .selectAll(".hour-label")
      .data(d3.range(0, 10, 1))
      .enter()
      .append("text")
      .attr("class", "hour-label")
      .attr("text-anchor", "middle")
      .attr("x", d => hourLabelRadius * Math.sin(ten(d) * radians))
      .attr(
        "y",
        d => -hourLabelRadius * Math.cos(ten(d) * radians) + hourLabelYOffset
      )
      .text(d => d);

    const hands = face.append("g").attr("id", "clock-hands");

    hands
      .selectAll("line")
      .data(handData)
      .enter()
      .append("line")
      .attr("class", d => d.type + "-hand")
      .attr("x1", 0)
      .attr("y1", d => d.balance || 0)
      .attr("x2", 0)
      .attr("y2", d => d.length)
      .attr("transform", d => `rotate(${d.scale(d.value)})`);

    face
      .append("g")
      .attr("id", "face-overlay")
      .append("circle")
      .attr("class", "hands-cover")
      .attr("x", 0)
      .attr("y", 0)
      .attr("r", clockRadius / 20);
  }

  function moveHands() {
    const sel = d3
      .select("#clock-hands-final")
      .selectAll("line")
      .data(handData)
      .transition();

    if (fancySecondsOFF) sel.ease(d3.easeElastic.period(0.5));
    sel.attr("transform", d => `rotate(${d.scale(d.value)})`);
  }
  
function unix2dote(unix, zone, offset = 719468) {
  return [
    (unix ?? Date.now()) / 86400000
    + (zone = zone ?? (10 - Math.round(
        (new Date).getTimezoneOffset() / 144)) % 10
      ) / 10 + offset, zone]
}
  

  function updateData() {
    const unix = Date.now();
    const declock = unix2dote(unix, long2zone(coordinates[0]))[0] % 1
    handData[0].value = Math.floor(declock * 10);
    handData[1].value = Math.floor(declock * 10 % 1 * 100);
    handData[2].value = !fancySecondsOFF ? declock * 10 % 1 * 100 % 1 * 100 : Math.floor(declock * 10 % 1 * 100 % 1 * 100);
  }

  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, w, h])
    .style("max-width", "500px")
    .attr("id", "clock");


  svg
    .append("text")
    .text(selected)
    .attr("x", clockRadius + margin)
    .attr("y", clockRadius * 2 + margin * 1.975)
    .attr("text-anchor", "middle")
    .attr("font-size", 32)
    .attr("font-family", "monospace");
  
  drawClock();

  // Animation
  const interval = setInterval(
    () => {
      updateData();
      moveHands();
    },
    !fancySecondsOFF ? 10 : 864
  );
  invalidation.then(() => clearInterval(interval));
  
  return svg.node();
}
```

```{ojs}
viewof fancySecondsOFF = Toggle({
  label: "Ticking clock",
  value: false
})
```

```{ojs}
viewof coordinates = worldMapCoordinates([162, 0], [width, Math.round((210 / 400) * width)])
```

```{ojs}
plot = Plot.plot({
  style: `overflow: visible;font-size:12px;margin-top:${-3 + (width < 400) * 3}px`,
  width: width * .96,
  y: {domain: [0, .92], grid: false},
  color: {legend: true, range: ["#ff6c00", "#009cff"]},
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(times, {x: "date", y: "rise", stroke: "symbol", strokeWidth: 16, strokeOpacity: .6}),
    Plot.lineY(times, {x: "date", y: "noon", stroke: "symbol", strokeWidth: 16, strokeOpacity: .6}),
    Plot.lineY(times, {x: "date", y: "set", stroke: "symbol", strokeWidth: 16, strokeOpacity: .6}),
    Plot.text(times, Plot.selectLast({x: "date", y: "rise", z: "symbol", text: d => `sunrise`, textAnchor: "start", dx: 9})),
    Plot.text(times, Plot.selectLast({x: "date", y: "noon", z: "symbol", text: d => `noon`, textAnchor: "start", dx: 9})),
    Plot.text(times, Plot.selectLast({x: "date", y: "set", z: "symbol", text: d => `sunset`, textAnchor: "start", dx: 9})),
  ]
})
```

```{ojs}
md`The bar chart and clock show zonal time,  which varies by time zone. Below the map there is a line plot that shows the zonal (blue) and local (orange) time when the sun sets (top line), reaches its peak (middle line), and rises (bottom line) throughout the year in the location selected on the map above the plot. Local time approximates [solar time](https://en.wikipedia.org/wiki/Solar_time#:~:text=the%20hour%20angle%20of%20the%20mean%20Sun%20plus%2012%20hours) by changing with longitude, even within the same time zone.`
```

```{ojs}
md`For daily use, we only need zonal time, which provides a single consistent time for each time zone, but local and solar time can be useful to understand how clock time compares to the position of the sun. To look at how solar time changes by location throughout the year, check out the top of the [Dec calculation notebook](/@dec/alc).`
```

```{ojs}
md`The map above shows how [Meridian 0](https://en.wikipedia.org/wiki/126th_meridian_west#:~:text=a%20line%20of%20longitude%20that%20extends%20from%20the%20North%20Pole%20across%20the%20Arctic%20Ocean%2C%20North%20America%2C%20the%20Pacific%20Ocean%2C%20the%20Southern%20Ocean%2C%20and%20Antarctica%20to%20the%20South%20Pole), the Dec [International Date Line](https://en.wikipedia.org/wiki/International_Date_Line#:~:text=the%20line%20between%20the%20South%20and%20North%20Poles%20that%20is%20the%20boundary%20between%20one%20calendar%20day%20and%20the%20next) and [prime meridian](https://en.wikipedia.org/wiki/Prime_meridian#:~:text=an%20arbitrarily%2Dchosen%20meridian%20%28a%20line%20of%20longitude%29%20in%20a%20geographic%20coordinate%20system%20at%20which%20longitude%20is%20defined%20to%20be%200%C2%B0), cuts across the Atlantic Ocean just West of Africa and marks the start of Zone 0, the leftmost Dec time zone on the map. Dec has 10 time zones which are each 1 deciturn (10% of a turn) wide and are numbered 0 through 9, like the [meridians](https://en.wikipedia.org/wiki/Meridian_%28geography%29#:~:text=words%2C%20it%20is-,a%20line%20of%20longitude,-.%20The%20position%20of) that separate them. For more Dec maps, check out these notebooks:
- [Decalc](/@dec/alc)
- [Decalendar](/@dec/al)
- [Decaliper](/@dec/ali)
- [Decirc](/@dec/irc)
- [Solar terminator](/@dec/solar-terminator)
- [The Sun's view of the Earth](/@dec/the-suns-view-of-the-earth)`
```

```{ojs}
md`[Analog clock](https://en.wikipedia.org/wiki/Clock#:~:text=use%20a%20clock%20face%20which%20indicates%20time%20using%20rotating%20pointers%20called%20%22hands%22%20on%20a%20fixed%20numbered%20dial%20or%20dials) displays are not necessary in Dec, because the time can simply be displayed as a single number. Nevertheless, a watch with an analog display can serve as an approximate compass during the daytime. Aligning the watch's deciday hand with the spot on the horizon below the Sun (the [solar azimuth](https://en.wikipedia.org/wiki/Solar_azimuth_angle#:~:text=horizontal%20angle%20with%20respect%20to%20north)) and our shadow, makes midnight and midday (0 and 5) on the watch align with North and South.`
```

```{ojs}
md`When facing North, the Sun will be on our right ([clock position](https://en.wikipedia.org/wiki/Clock_position#:~:text=a%20system%20of%20denoting%20impromptu%20relative%20bearing%20widely%20used%20in%20practical%20navigation%20to%20give%20the%20position%20of%20an%20observed%20object) < .5 turns) and in the East (solar azimuth < .5 turns) before [solar noon](https://en.wikipedia.org/wiki/Noon#Solar_noon:~:text=the%20moment%20when%20the%20Sun%20contacts%20the%20observer%27s%20meridian%20%28culmination%20or%20meridian%20transit%29%2C%20reaching%20its%20highest%20position%20above%20the%20horizon%20on%20that%20day) (solar time < .5 turns), and on our left (clock position > .5 turns) and in the West (solar azimuth > .5 turns) after solar noon (solar time > .5 turns). This method works everywhere even though the solar azimuth at solar noon is .5 turns (South) in the Northern Hemisphere (latitude > 0 turns) and 0 turns (North) in the Southern Hemisphere (latitude < 0 turns).`
```

```{ojs}
md`## Zonal, Local, Solar time comparison`
```

```{ojs}
md`In Declock, times that are offset by integer deciturns (tenths of a turn) are called zonal times. In the plot above, the zonal times (orange lines) for sunrise (bottom orange line), [solar noon](https://en.wikipedia.org/wiki/Noon#:~:text=Solar%20noon%20is%20the%20time,be%20observed%20using%20a%20sundial.) (middle orange line), and sunset (top orange line) change significantly when the red circle is moved left or right to change the longitude. In contrast, local times (blue lines) and solar times (orange lines) for sunrise (bottom), solar noon (middle), and sunset (top) differ by latitude by not longitude. `
```

```{ojs}
md`Zonal times can be displayed in decidays with a time zone (${selected}) or without a time zone in other units such as millidays (${Math.floor(selected.slice(0, 6)*100)}) or centimillidays (${Math.floor(selected.slice(0, 6)*10000)}). Centimillidays are similar in duration to heartbeats or musical beats and thus are also known as beats. The local and solar time equivalent of a time zone is the longitude in the same units and at the same level of precision as the time (${String(unix2dote(unix, long2zone(coordinates[0]))[0] % 1 * 10).slice(0, 6)}-${long2turn(coordinates[0], 1).toFixed(4)}). A centimilliturn of longitude [at the equator](https://en.wikipedia.org/wiki/Longitude#Length_of_a_degree_of_longitude) is 400.75017 meters, which is a hundred thousandth (0.001%) of the [Earth's equatorial circumference](https://en.wikipedia.org/wiki/Earth%27s_circumference#:~:text=Measured%20around%20the%20equator%2C%20it%20is%2040%2C075.017%C2%A0km).`
```

```{ojs}
md`Zonal time behaves differently than local and solar time because it keeps one time per time zone. In contrast, local and solar times vary by longitude, even within the same time zone. For daily use, we only need zonal times, but local and solar times can be useful to understand how clock time compares to the position of the sun.`
```

```{ojs}
md`Zonal and local times are identical in the middle of time zones and will differ by 5 centidays at time zone borders. Local times use exact floating decimal deciday values to obtain a closer match between Declock noon (.5) and solar noon, the time of day when the sun is in its highest position in the sky. In contrast to zonal time and local time, solar time is based on the sun's [azimuth](https://en.wikipedia.org/wiki/Solar_azimuth_angle#:~:text=horizontal%20angle%20with%20respect%20to%20north) or [hour angle](https://en.wikipedia.org/wiki/Hour_angle#:~:text=an%20expression%20of%20time%2C%20expressed%20in%20angular%20measurement%2C%20usually%20degrees%2C%20from%20solar%20noon) and thus should always be exactly .5 at solar noon. Since solar noon in solar time is expected to be .5 all-year-round, it is not shown in the plot above.`
```

```{ojs}
md`People living closer to time zone midpoints enjoy a closer match between clock noon and solar noon. This can help them anticipate the amount of sunlight they will receive in their location. Additionally, we can obtain solar time with a compass, a horizontal sundial, or any other means of determining the sun's azimuth. These direct measures of solar azimuth can be used to confirm [solar azimuth calculations](https://observablehq.com/@mourner/sun-position-in-900-bytes).`
```

```{ojs}
md`To obtain solar time (${tex`ST`}), we express the Sun's azimuth (${tex`\phi`}) or hour angle (${tex`h`}) in turns or days instead of degrees and if necessary shift by half a day so that the Declock solar time is .5 days (12 hours) at solar noon. Solar azimuth measured in the Northern hemisphere (${tex`\phi_N`}) does not require any adjustment, because it is naturally .5 turns (180Â°) from North, or in other words exactly South, at solar noon. In contrast, ${tex`h`} and Southern hemisphere solar azimuth (${tex`\phi_S`}) are 0 at solar noon. 

To make ${tex`h`} match ${tex`ST`}, we only need to [add a half-day](https://en.wikipedia.org/wiki/Solar_time#:~:text=the%20hour%20angle%20of%20the%20mean%20sun%20plus%2012%20hours) to ${tex`h`} (${tex`h+.5`}). To obtain ${tex`ST`} from the Southern hemisphere solar azimuth (${tex`\phi_S`}), we need to subtract (${tex`\phi_S`}) from 1.5 (${tex`1.5-\phi_S`}) and then [keep the remainder](https://en.wikipedia.org/wiki/Modulo#:~:text=returns%20the%20remainder%20or%20signed%20remainder%20of%20a%20division) ([%](https://en.wikipedia.org/wiki/Modulo#:~:text=use%20%22%25%22%2C%20%22mod%22%2C%20or%20%22mod%22%20as%20a%20modulo%20or%20remainder%20operator)) after dividing by 1 (${tex`(1.5-\phi_S)\text{ \% }1`}), because the Sun moves clockwise in the Northern hemisphere and [counterclockwise](https://en.wikipedia.org/wiki/Solar_azimuth_angle#:~:text=take%20counterclockwise%20angles%20as%20negative) in the Southern hemisphere.<br>
${tex`ST=\phi_N=h+.5=(1.5-\phi_S)\text{ \% }1`}`
```

```{ojs}
md`## Declock and UTC time zone comparison`
```

```{ojs}
md`There are more than 24 UTC time zone offsets, but only 10 Declock time zones. This notebook and the [Decalc notebook](/@dec/alc) have interactive maps that visualize Declock time zones. You can also see the Declock time zones on the world maps at the top of the [Decircle labels](/@dec/irc), [solar terminator](/@dec/solar-terminator) notebook, and the [Sun's view of the Earth](/@dec/the-suns-view-of-the-earth) notebook. On all of these maps, the vertical graticules (lines on a map) separate Declock time zones. If you know your longitude in degrees (Â°) or centidays (cd), you can look up your Declock time zone in the table below.

| TZ+ | TZ- | Start (Â°) | Mid (Â°) | End (Â°) | Start (cd) | Mid (cd) | End (cd) |
| --- | --- | ---       | ---     | ---     |   ---      | ---      | ---      |
| 9   | -1  |  -54      | -36     | -18     |   90       | 95       | 100      |
| 8   | -2  |  -90      | -72     | -54     |   80       | 85       | 90       |
| 7   | -3  |  -126     | -108    | -90     |   70       | 75       | 80       |
| 6   | -4  |  -162     | -144    | -126    |   60       | 65       | 70       |
| 5   | -5  |  162      | 180     | -162    |   50       | 55       | 60       |
| 4   | -6  |  126      | 144     | 162     |   40       | 45       | 50       |
| 3   | -7  |  90       | 108     | 126     |   30       | 35       | 40       |
| 2   | -8  |  54       | 72      | 90      |   20       | 25       | 30       |
| 1   | -9  |  18       | 36      | 54      |   10       | 15       | 20       |
| 0   | -10 | -18       | 0       | 18      |   0        | 5        | 10       |`
```

```{ojs}
md`Essentially, Declock combines several UTC time zones to form each of its time zones. This is only a rough approximation, because UTC time zones are [a hot mess](https://observablehq.com/@mbostock/time-zones) and Declock time zones are determined solely by longitude (as shown in the table above), not geographic or political boundaries. Nevertheless, a mapping of Dec time zones to UTC time zones can be useful:

| TZ+ | TZ- | UTC | NATO | Abbreviations                                                            |
| --- | --  | --- | ---- | ----                                                                     |
| 0   | -10 | -1  | N    | AZOT, CVT, EGT                                                           |
| 0   | -10 | 0   | Z    | AZOST, EGST, GMT, UTC, WET                                               |
| 0   | -10 | 1   | A    | BST, CET, DFT, IST, MET, WAT, WEST                                       |
| 1   | -9  | 2   | B    | CAT, CEST, EET, HAEC, IST, KALT, MEST, SAST, WAST                        |
| 1   | -9  | 3   | C    | AST, EAT, EEST, FET, IDT, IOT, MSK, SYOT, TRT, VOLT                      |
| 2   | -8  | 4   | D    | AMT, AZT, GET, GST, MUT, RET, SAMT, SCT                                  |
| 2   | -8  | 5   | E    | AQTT, HMT, MAWT, MVT, ORAT, PKT, TFT, TJT, TMT, UZT, YEKT                |
| 2   | -8  | 6   | F    | ALMT, BIOT, BST, BTT, KGT, OMST, VOST                                    |
| 3   | -7  | 7   | G    | CXT, DAVT, HOVT, ICT, KRAT, NOVT, THA, WIB                               |
| 3   | -7  | 8   | H    | ACT, AWST, BNT, CHOT, CST, HKT, HOVST, IRKT, MST, MYT, PHST, PHT, SGT, SST, ULAT, WITA, WST |
| 4   | -6  | 9   | I    | CHOST, JST, KST, PWT, TLT, ULAST, WIT, YAKT                              |
| 4   | -6  | 10  | K    | AEST, CHST, CHUT, DDUT, PGT, VLAT                                        |
| 5   | -5  | 11  | L    | AEDT, BST, KOST, LHST, MIST, NCT, NFT, PONT, SAKT, SBT, SRET, VUT        |
| 5   | -5  | 12  | M    | ANAT, FJT, GILT, MAGT, MHT, NZST, PETT, TVT, WAKT                        |
| 5   | -5  | -12 | Y    | BIT, IDLW                                                                |
| 5   | -5  | -11 | X    | NUT, SST                                                                 |
| 6   | -4  | -10 | W    | CKT, HST, SDT, TAHT                                                      |
| 6   | -4  | -9  | V    | AKST, HDT, GAMT, GIT                                                     |
| 7   | -3  | -8  | U    | AKDT, CIST, PST                                                          |
| 7   | -3  | -7  | T    | MST, PDT                                                                 |
| 7   | -3  | -6  | S    | CST, EAST, GALT, MDT                                                     |
| 8   | -2  | -5  | R    | ACT, CDT, COT, CST, EASST, ECT, EST, PET                                 |
| 8   | -2  | -4  | Q    | AMT, AST, BOT, CDT, CLT, COST, ECT, EDT, FKT, GYT, PYT, VET              |
| 9   | -1  | -3  | P    | ADT, AMST, ART, BRT, CLST, FKST, GFT, PMST, PYST, ROTT, SRT, UYT, WGT    |
| 9   | -1  | -2  | O    | BRST, FNT, GST, PMDT, UYST, WGST                                         |

The table only includes UTC offsets that have [NATO letter codes](https://en.wikipedia.org/wiki/Military_time_zone#:~:text=a%20standardized%2C%20uniform%20set%20of%20time%20zones%20for%20expressing%20time%20across%20different%20regions%20of%20the%20world%2C%20named%20after%20the%20NATO%20phonetic%20alphabet). Declock considers the M and Y time zones to be identical and puts them both in Zone 5 along with the L and X time zones. According to UTC, the M and Y time zones have the same time of day, but their dates differ by 1 day.ðŸ˜±
Several countries have floating decimal offsets, such as Iran and India, and are thus not represented in this table. Based on longitude, Iran is in Zone 1 and India is in Zone 2, but their UTC offsets are both in Zone 2 during Daylight Savings Time (DST) and in Zone 1 otherwise. I think this is another great example of how Dec is superior to our current time system. Dec has only 10 whole number time zones that never shift but local and solar time essentially offer infinite time zones by providing a different time zone at every longitude.`
```

```{ojs}
md`## Dec and UTC time zone differences

The greatest difference between a Declock time zone and the corresponding UTC time zone is 5 centiday (1.2 hours or 72 minutes). 
There is no difference between Zone 0 and UTCÂ±00:00 or between Zone 5 and UTCÂ±12:00.`
```

```{ojs}
md`### Zone 7 and Central Time
Difference: 5 centiday (72 minutes)`
```

```{ojs}
now.toLocaleTimeString("en-US", {timeZone: "Etc/GMT+6", hour12: false});
```

```{ojs}
`${Math.floor(zone7hour).toString().padStart(2, "0")}:${Math.floor(zone7min).toString().padStart(2, "0")}:${Math.floor(zone7sec).toString().padStart(2, "0")}`
```

```{ojs}
md`The difference between Central Time and Zone 7 is the highest possible: 5 centiday (72 minutes). In Dec, longitudes are measured starting from [Meridian 0](https://en.wikipedia.org/wiki/18th_meridian_west#:~:text=a%20line%20of%20longitude%20that%20extends%20from%20the%20North%20Pole%20across%20the%20Arctic%20Ocean%2C%20Greenland%2C%20Iceland%2C%20the%20Atlantic%20Ocean%2C%20the%20Canary%20Islands%2C%20the%20Southern%20Ocean%2C%20and%20Antarctica%20to%20the%20South%20Pole), the start of Zone 0 (-18Â°).  Meridian 0 is both the [Prime Meridian](https://en.wikipedia.org/wiki/Prime_meridian) and the [International Date Line](https://en.wikipedia.org/wiki/International_Date_Line#:~:text=the%20line%20between%20the%20South%20and%20North%20Poles%20that%20is%20the%20boundary%20between%20one%20calendar%20day%20and%20the%20next) in Dec. If we created a new Declock time zone called Zone 75 that started in between Zone 7 and Zone 8 on [Meridian 75](https://en.wikipedia.org/wiki/108th_meridian_west#:~:text=a%20line%20of%20longitude%20that%20extends%20from%20the%20North%20Pole%20across%20the%20Arctic%20Ocean%2C%20North%20America%2C%20the%20Pacific%20Ocean%2C%20the%20Southern%20Ocean%2C%20and%20Antarctica%20to%20the%20South%20Pole) (-108Â°), it would match Central Time exactly.`
```

```{ojs}
zone75hour = (zone0 + .75) % 1 * 24
```

```{ojs}
zone75min = zone75hour % 1 * 60
```

```{ojs}
zone75sec = zone75min % 1 * 60
```

```{ojs}
`${Math.floor(zone75hour).toString().padStart(2, "0")}:${Math.floor(zone75min).toString().padStart(2, "0")}:${Math.floor(zone75sec).toString().padStart(2, "0")}`
```

```{ojs}
now.toLocaleTimeString("en-US", {timeZone: "America/Mexico_City", hour12: false});
```

```{ojs}
md`### Zone 8 and Eastern Time
Difference: ${tex`.8\overline3`} centiday (12 minutes)`
```

```{ojs}
now.toLocaleTimeString("en-US", {timeZone: "EST", hour12: false});
```

```{ojs}
`${Math.floor(zone8hour).toString().padStart(2, "0")}:${Math.floor(zone8min).toString().padStart(2, "0")}:${Math.floor(zone8sec).toString().padStart(2, "0")}`
```

```{ojs}
md`### Zone 0 and UTC+00:00
Difference: None!`
```

```{ojs}
now.toLocaleTimeString("en-US", {timeZone: "Etc/UTC", hour12: false});
```

```{ojs}
`${Math.floor(zone0hour).toString().padStart(2, "0")}:${Math.floor(zone0min).toString().padStart(2, "0")}:${Math.floor(zone0sec).toString().padStart(2, "0")}`
```

```{ojs}
md`### Zone 5 and UTCÂ±12:00
Difference: None!`
```

```{ojs}
now.toLocaleTimeString("en-US", {timeZone: "Etc/GMT+12", hour12: false});
```

```{ojs}
now.toLocaleTimeString("en-US", {timeZone: "Etc/GMT-12", hour12: false});
```

```{ojs}
`${Math.floor(zone5hour).toString().padStart(2, "0")}:${Math.floor(zone5min).toString().padStart(2, "0")}:${Math.floor(zone5sec).toString().padStart(2, "0")}`
```

```{ojs}
md`Declock time zones go in increments of
- 1 deciday
- 36 degrees
- 1.2 (6/5) hours
- 72 minutes
- 4320 seconds

If we split each of these time zones in half, we would have 21 time zones (Zone 00 to Zone 95) that went in increments of
- 5 centiday
- 18 degrees
- .6 (3/5) hours
- 36 minutes
- 2160 seconds

This would be close to the number of UTC offsets, but probably not worth the trouble. That being said, if someone reports their time as 25.00-25, quarterday (6AM) in Zone 25, we will know that this is the same as 5.00-5, noon (12PM) in Zone 5.`
```

```{ojs}
md`Apart from different time zones, Declock times can differ from UTC times because of DST. Declock times never shift! The standard DST practice of switching to a different time zone (e.g. EST to EDT) for certain parts of the year (e.g Day 9 to Day 277) could work for Declock, but that goes against the simplicity of determining time zones solely by longitude.

Of course, a country can decide to only have 1 time zone within its borders (China does this with UTC time zones). In fact, it would be OK to have anyone use whatever time zone they want as long as times are always provided with time zones, because it is easy to convert times across time zones: just increment or decrement the one-digit time zone along with the first digit of the time. 

When it is midday (.5 or 12pm) in Alaska and Hawaii, it is midnight (.0 or 12AM) in  Ukraine and Turkey: .5.0 = .0.5

When it is quadrans (.25 or 6AM) in England, it is dodrans (.75 or 6PM) in New Zealand: .25.4 = .75.9`
```

```{ojs}
md`## Declock Time Zone Conversion`
```

```{ojs}
md`The `unix2dote` function below determined your time zone to be Zone ${local[1]} based on the [UTC offset](https://en.wikipedia.org/wiki/UTC_offset#:~:text=difference%20in%20hours%20and%20minutes%20between%20Coordinated%20Universal%20Time%20%28UTC%29%20and%20local%20solar%20time) it obtained for your web browser.`
```

```{ojs}
local = unix2dote(unix)
```

```{ojs}
function unix2dote(unix, zone, offset = 719468) {
  return [
    (unix ?? Date.now()) / 86400000
    + (zone = zone ?? (10 - Math.round(
        (new Date).getTimezoneOffset() / 144)) % 10
      ) / 10 + offset, zone]
}
```

```{ojs}
md`To convert to other a time to another time zone, add or subtract multiples of a deciday (a tenth of a day). This addition or subtraction is the same as using a time zone offset. Dec time zone numbers work like [array indexes](https://en.wikipedia.org/wiki/Array_%28data_structure%29#Element_identifier_and_addressing_formulas:~:text=The%20first%20element%20of%20the%20array%20is%20indexed%20by%20subscript%20of%200) and time zone offsets. We can switch between positive and negative indexes by adding 10 to positive indexes and subtracting 10 from negative indexes. We can add a positive or a negative index to Zone 0 time and obtain the time in the target time zone. Adding positive offsets always works, but adding a negative offset to a date with a time will give us the correct time on yesterday's date rather than today's date.`
```

```{ojs}
md`### Zone 1 time`
```

```{ojs}
zone1 = zone0 + .1
```

```{ojs}
zone1timeNum = zone1 % 1
```

```{ojs}
zone1timeStr = zone1timeNum.toString().slice(2, 7)
```

```{ojs}
md`### Zone 2 time`
```

```{ojs}
zone2 = zone0 + .2
```

```{ojs}
zone2timeNum = zone2 % 1
```

```{ojs}
zone2timeStr = zone2timeNum.toString().slice(2, 7)
```

```{ojs}
md`### Zone 3 time`
```

```{ojs}
zone3 = zone0 + .3
```

```{ojs}
zone3timeNum = zone3 % 1
```

```{ojs}
zone3timeStr = zone3timeNum.toString().slice(2, 7)
```

```{ojs}
md`### Zone 4 time`
```

```{ojs}
zone4 = zone0 + .4
```

```{ojs}
zone4timeNum = zone4 % 1
```

```{ojs}
zone4timeStr = zone4timeNum.toString().slice(2, 7)
```

```{ojs}
md`### Zone 5 time`
```

```{ojs}
zone5 = zone0 + .5
```

```{ojs}
zone5timeNum = zone5 % 1
```

```{ojs}
zone5timeStr = zone5timeNum.toString().slice(2, 7)
```

```{ojs}
md`### Zone 6 time`
```

```{ojs}
zone6 = zone0 + .6
```

```{ojs}
zone6timeNum = zone5 % 1
```

```{ojs}
zone6timeStr = zone6timeNum.toString().slice(2, 7)
```

```{ojs}
md`### Zone 7 time`
```

```{ojs}
zone7 = zone0 + .7
```

```{ojs}
zone7timeNum = zone7 % 1
```

```{ojs}
zone7timeStr = zone7timeNum.toString().slice(2, 7)
```

```{ojs}
md`### Zone 8 time`
```

```{ojs}
zone8 = zone0 + .8
```

```{ojs}
zone8timeNum = zone8 % 1
```

```{ojs}
zone8timeStr = zone8timeNum.toString().slice(2, 7)
```

```{ojs}
md`### Zone 9 time`
```

```{ojs}
zone9 = zone0 + .9
```

```{ojs}
zone9timeNum = zone9 % 1
```

```{ojs}
zone9timeStr = zone9timeNum.toString().slice(2, 7)
```

```{ojs}
md`## Calculate Declock times from UNIX time`
```

```{ojs}
md`Obtain UNIX time.`
```

```{ojs}
unix = {
  while(true) {
    yield Date.now();
  }
}
```

```{ojs}
md`To convert [UNIX time](https://en.wikipedia.org/wiki/Unix_time#:~:text=a%20date%20and%20time%20representation%20widely%20used%20in%20computing) to Declock time, divide by 86400000 and take the number after the decimal. The resulting time is in Declock Time Zone 0, which has the same midpoint as UTC (0 degrees). The Dec calendar (Decalendar) version of the UNIX [epoch](https://en.wikipedia.org/wiki/Epoch_%28computing%29#:~:text=a%20fixed%20date%20and%20time%20used%20as%20a%20reference%20from%20which%20a%20computer%20measures%20system%20time.) is Year 1969 Day 306 or `1969+3060.00000-4` in the `year+dday.dday-z` timestamp format. The number shown below is the number of days since the UNIX epoch. Cool but useless fact: the UNIX epoch in Zone 6 decimal years is `1969.84`!`
```

```{ojs}
md`### Zone 0 time`
```

```{ojs}
zone0 = unix / 86400000
```

```{ojs}
zone0timeNum = zone0 % 1
```

```{ojs}
zone0timeStr = zone0timeNum.toString().slice(2, 7)
```

```{ojs}
md`This simple calculation is all it takes to obtain the time in Declock Time Zone 0!`
```

```{ojs}
md`## Convert HH:MM:SS time to Declock time`
```

```{ojs}
md`${tex`declock = \frac{hour}{24} + \frac{minute}{1440} + \frac{second}{86400}`}`
```

```{ojs}
now = {
  while(true) {
    yield new Date();
  }
}
```

```{ojs}
now.getUTCHours() / 24 + now.getUTCMinutes() / 1440 + now.getUTCSeconds() / 86400 + now.getUTCMilliseconds() / 86400000
```

```{ojs}
zone0timeNum
```

```{ojs}
md`## Convert Declock time to HH:MM:SS time`
```

```{ojs}
md`${tex`hour = declock \cdot 24`}`
```

```{ojs}
md`
${tex`minute = \frac{hour - \lfloor hour \rfloor}{60}`}
`
```

```{ojs}
md`${tex`second = \frac{minute - \lfloor minute \rfloor}{60}`}`
```

```{ojs}
md`### Hours`
```

```{ojs}
zone0hour = zone0timeNum * 24
```

```{ojs}
zone1hour = zone1timeNum * 24
```

```{ojs}
zone2hour = zone2timeNum * 24
```

```{ojs}
zone3hour = zone3timeNum * 24
```

```{ojs}
zone4hour = zone4timeNum * 24
```

```{ojs}
zone5hour = zone5timeNum * 24
```

```{ojs}
zone6hour = zone6timeNum * 24
```

```{ojs}
zone7hour = zone7timeNum * 24
```

```{ojs}
zone8hour = zone8timeNum * 24
```

```{ojs}
zone9hour = zone9timeNum * 24
```

```{ojs}
md`### Minutes`
```

```{ojs}
zone0min = zone0hour % 1 * 60
```

```{ojs}
zone1min = zone1hour % 1 * 60
```

```{ojs}
zone2min = zone2hour % 1 * 60
```

```{ojs}
zone3min = zone3hour % 1 * 60
```

```{ojs}
zone4min = zone4hour % 1 * 60
```

```{ojs}
zone5min = zone5hour % 1 * 60
```

```{ojs}
zone6min = zone6hour % 1 * 60
```

```{ojs}
zone7min = zone7hour % 1 * 60
```

```{ojs}
zone8min = zone8hour % 1 * 60
```

```{ojs}
zone9min = zone9hour % 1 * 60
```

```{ojs}
md`### Seconds`
```

```{ojs}
zone0sec = zone0min % 1 * 60
```

```{ojs}
zone1sec = zone1min % 1 * 60
```

```{ojs}
zone2sec = zone2min % 1 * 60
```

```{ojs}
zone3sec = zone3min % 1 * 60
```

```{ojs}
zone4sec = zone4min % 1 * 60
```

```{ojs}
zone5sec = zone5min % 1 * 60
```

```{ojs}
zone6sec = zone6min % 1 * 60
```

```{ojs}
zone7sec = zone7min % 1 * 60
```

```{ojs}
zone8sec = zone8min % 1 * 60
```

```{ojs}
zone9sec = zone9min % 1 * 60
```

```{ojs}
md`## Martian and Earth time comparison`
```

```{ojs}
md`We can use a similar calculation to get the time in Time Zone 0 on Mars. The only difference is that we add 117 days to go from 1969+3060.0000-0 to 1970+0580.0000-0, an Earth date that coincides with the [northward spring equinox on Mars](https://en.wikipedia.org/wiki/Timekeeping_on_Mars#Year_numbering), and divide by 1.02749125 to convert Earth days to Martian days.`
```

```{ojs}
marsZone0timeNum = (unix / 86400000 + 6065.5848348500847758) / 1.0274912517 % 1
```

```{ojs}
marsZone0timeStr = marsZone0timeNum.toString().slice(2, 7)
```

```{ojs}
md`Earth time is about 2.75% faster than Martian time. This difference is noticeably when comparing the time since this webpage loaded in Earth beats (centimillidays) and Martian beats (centimillisols).`
```

```{ojs}
tick = {
  let i = 0;
  while (true) {
    yield Promises.tick(864, ++i);
  }
}
```

```{ojs}
mars_tick = Math.round(tick / 1.0274912517)
```

```{ojs}
md`At the top of the [Decalendar notebook](/@dec/al), you can find the current Dec timestamp in Zone 0 on Earth and Mars.`
```

```{ojs}
md`### Martian time zones

If we have the longitude of other points of interest on Mars, such as Martian rover landing sites, we can calculate their zonal and local Declock time. Declock time zones can be applied to Mars or any other celestial body, as long as we can select a longitude to serve as the center of that planet's Zone 0. Finding a Zone 0 midpoint is easy for [rocky planets](https://en.wikipedia.org/wiki/Terrestrial_planet#:~:text=a%20planet%20that%20is%20composed%20primarily%20of%20silicate%2C%20rocks%20or%20metals) without super dense atmospheres, but may be hard for other celestial bodies, like perpetually cloud-covered Venus or the gas giant Jupiter. The midpoint of Zone 0 on Earth is [Greenwich](https://en.wikipedia.org/wiki/Prime_meridian_%28Greenwich%29), while the analogous point on Mars is a crater called [Airy-0](https://en.wikipedia.org/wiki/Airy-0#:~:text=a%20crater%20inside%20the%20larger%20Airy%20Crater%20on%20Mars), which is centered on the Mars globe and map below. The longitude at Airy-0 is 5 [ctr](https://en.wikipedia.org/wiki/Turn_%28angle%29#:~:text=in%2C%20e.g.%2C-,centiturns%20%28ctr%29,-%2C%20milliturns%20%28mtr%29%2C%20etc), as measured from [Meridian](https://en.wikipedia.org/wiki/162nd_meridian_west#:~:text=a%20line%20of%20longitude%20that%20extends%20from%20the%20North%20Pole%20across%20the%20Arctic%20Ocean%2C%20North%20America%2C%20the%20Pacific%20Ocean%2C%20the%20Southern%20Ocean%2C%20and%20Antarctica%20to%20the%20South%20Pole) 0, the Dec [prime meridian](https://en.wikipedia.org/wiki/Prime_meridian#:~:text=an%20arbitrarily%2Dchosen%20meridian%20%28a%20line%20of%20longitude%29%20in%20a%20geographic%20coordinate%20system%20at%20which%20longitude%20is%20defined%20to%20be%200%C2%B0).`
```

```{ojs}
globe = {  
  while (true) {
    renderer.render(scene, camera);
    yield renderer.domElement;
  }
}
```

```{ojs}
naturalEarth = d3.image(
  "https://upload.wikimedia.org/wikipedia/commons/b/b7/Mars_G%C3%A9olocalisation.jpg",
//  naturalEarth = d3.image(
//  "https://media.opennews.org/img/how-we-made-rewind-the-red/mars-base_4k.jpg",
  
  {crossOrigin: "anonymous"})
// {
//     const image = new Image;
//     image.crossOrigin = "anonymous";
//     image.src = "https://gist.githubusercontent.com/jake-low/d519e00853b15e9cec391c3dab58e77f/raw/6e796038e4f34524059997f8e1f1c42ea289d805/ne1-small.png";
//     image.onload = () => resolve(image);
//     image.onerror = reject;
//   });
```

```{ojs}
md`## Appendix`
```

```{ojs}
camera = {
  const camera = new THREE.PerspectiveCamera(8, 2, 0.1, 60);
  camera.position.set(-12, 0, 0);
  return camera;
}
```

```{ojs}
scene = {
  let scene = this;
  
  if (!scene) {
    scene = new THREE.Scene();
    scene.background = new THREE.Color('#f5f5f5');
    scene.add(earth, orbit, light);
  }

  return scene;
}
```

```{ojs}
renderer = {
  const renderer = new THREE.WebGLRenderer({antialias: true})
    
  renderer.setSize(width, width / 2);
  renderer.setPixelRatio(devicePixelRatio);
  
  invalidation.then(() => renderer.dispose());
  
  return renderer;
}
```

```{ojs}
controls = {
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.minDistance = 3;
  controls.maxDistance = 20;
  
  const redraw = () => renderer.render(scene, camera);
  
  controls.addEventListener("change", redraw);
  
  invalidation.then(() => {
    controls.removeEventListener("change", redraw);
    controls.dispose();
  });
  
  return controls;
}
```

```{ojs}
//light = new THREE.AmbientLight('#fff')
light = {
  const light = new THREE.Group();

  const ambient = new THREE.AmbientLight("#888")
  const directional = new THREE.DirectionalLight("#aaa")
  directional.position.x = -180;
  
  light.add(ambient, directional)
  return light;
}
```

```{ojs}
earth = {
  let earth = this;
  
  if (!earth) {
    earth = new THREE.Mesh();
    earth.geometry = new THREE.SphereBufferGeometry(1, 40, 40);
    earth.rotation.y = Math.PI;
  }
  
  return earth;
}
```

```{ojs}
orbit = {
  let orbit = this;
  
  if (!orbit) {
    orbit = new THREE.Group();    
    // orbit.add(track, satellite);
  }
    
  // orbit.rotation.x = satelliteInclination * Math.PI / 180;
  
  return orbit;
}
```

```{ojs}
texture = {
  let texture = this;
  
  if (!texture) {
    texture = new THREE.CanvasTexture(map);
    earth.material = new THREE.MeshLambertMaterial({ map: texture });
  } else {
    texture.needsUpdate = true;
  }
  
  return texture;
}
```

```{ojs}
THREE = {
  const THREE = window.THREE = await require("three@0.97/build/three.min.js");
  await require("three@0.97/examples/js/controls/OrbitControls.js").catch(() => {});
  await require("three@0.97/examples/js/loaders/OBJLoader.js").catch(() => {});
  await require("three@0.97/examples/js/loaders/MTLLoader.js").catch(() => {});
  return THREE;
}
```

```{ojs}
map = {
  let canvas = this;

  if (!canvas) {
    canvas = DOM.context2d(width, width/2).canvas;
  }
  
  let context = canvas.getContext("2d");

  const path = d3.geoPath()
    .projection(projection)
    .context(context);
  
  context.drawImage(naturalEarth, 0, 0, width, width/2);

 
  return canvas;
}
```

```{ojs}
projection = d3.geoEquirectangular()
  .fitSize([width, width/2], { type: 'Sphere' })
  .precision(0.1)
```

```{ojs}
import { slider } from "@jashkenas/inputs"
```

```{ojs}
import { Toggle } from "@observablehq/inputs"
```

```{ojs}
selected = `${String(unix2dote(unix, long2zone(coordinates[0]))[0] % 1 * 10).slice(0, 6)}-${long2zone(coordinates[0])}`
```

```{ojs}
function long2zone(degrees = -180) {
  return Math.floor(long2turn(degrees, 1));
}
```

```{ojs}
function long2turn(degrees = -180, e = 3) {
  // turns: e=0, deciturns: e=1, etc.
  return (((degrees %= 360) < 0 ? degrees + 360 : degrees) + 18) / (360 / 10**e) % 10**e;
}
```

```{ojs}
function lati2turn(degrees = -180, e = 3) {
  // turns: e=0, deciturns: e=1, etc.
  return ((degrees %= 360) < 0 ? degrees + 360 : degrees) / (360 / 10**e) % 10**e;
}
```

```{ojs}
function lati2turn1(degrees = -180, e = 3) {
  // turns: e=0, deciturns: e=1, etc.
  return (degrees %= 360) / (360 / 10**e) % 10**e;
}
```

```{ojs}
solar1 = (await require("solar-calculator@0.2"))(coordinates)
```

```{ojs}
borders = topojson.mesh(countryBorders, countryBorders.objects.countries, (a, b) => a !== b)
```

```{ojs}
countryBorders = fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-50m.json").then(response => response.json())
```

```{ojs}
boundaries = topojson.mesh(world,world.objects.countries, (a, b) => a !== b);
```

```{ojs}
sun = {
  const now = new Date;
  const day = new Date(+now).setUTCHours(0, 0, 0, 0);
  const t = solar.century(now);
  const longitude = (day - now) / 864e5 * 360 - 180;
  return [longitude - solar.equationOfTime(t) / 4, solar.declination(t)];
}
```

```{ojs}
night = d3.geoCircle()
    .radius(90)
    .center(antipode(sun))
  ()
```

```{ojs}
antipode = ([longitude, latitude]) => [longitude + 180, -latitude]
```

```{ojs}
solar = require("solar-calculator@0.3/dist/solar-calculator.min.js")
```

```{ojs}
SunCalc = require("suncalc3")
```

```{ojs}
pos = SunCalc.getPosition(Date.now(), coordinates[1], coordinates[0])
```

```{ojs}
pos["azimuth"] * 180 / Math.PI
```

```{ojs}
pos["azimuth"] / (2 * Math.PI)
```

```{ojs}
pos["declination"] * 180 / Math.PI
```

```{ojs}
pos["zenith"] * 180 / Math.PI
```

```{ojs}
style = html`<style>

#clock {
  stroke: #000;
  font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif; 
}

#clock #rim {
  fill: none;
  stroke: #999;
  stroke-width: 3px;
}

#clock .second-hand {
  stroke-width:3;
}

#clock .minute-hand {
  stroke-width:8;
  stroke-linecap:round;
}

#clock .hour-hand {
  stroke-width:12;
  stroke-linecap:round;
}

#clock .hands-cover {
  stroke-width:3;
  fill:#fff;
}

#clock .second-tick {
  stroke-width:3;
  fill:#000;  
}

#clock .hour-tick {
  stroke-width:8; // same as the minute hand
}

#clock .second-label {
  font-size: 12px;
}

#clock .hour-label {
  font-size: 24px;
}

</style>`
```

```{ojs}
dateRange = d3.utcDay.range(new Date("2024-03-02"), new Date("2025-03-02"))
```

```{ojs}
noons = dateRange.map(d => SunCalc.getSunTimes(d, coordinates[1], coordinates[0])["solarNoon"]["value"])
```

```{ojs}
rises = dateRange.map(d => SunCalc.getSunTimes(d, coordinates[1], coordinates[0])["sunriseStart"]["value"])
```

```{ojs}
sets = dateRange.map(d => SunCalc.getSunTimes(d, coordinates[1], coordinates[0])["sunsetEnd"]["value"])
```

```{ojs}
zonalNoons = noons.map(d => d.getTime() / 86400000 - .4 + Math.round((144 + coordinates[0]) / 36) / 10).map(d => d % 1)
```

```{ojs}
zonalRises = rises.map(d => d.getTime() / 86400000 - .4 + Math.round((144 + coordinates[0]) / 36) / 10).map(d => d % 1).map(d => d >= .5 || d <= .05 ? NaN : d)
```

```{ojs}
zonalSets = sets.map(d => d.getTime() / 86400000 - .4 + Math.round((144 + coordinates[0]) / 36) / 10).map(d => d % 1).map(d => d <= .5 || d >= .95 ? NaN : d)
```

```{ojs}
localNoons = noons.map(d => ((d.getTime() / 86400000 - .4 + (144 + coordinates[0]) / 360))).map(d => d % 1)
```

```{ojs}
localRises = rises.map(d => ((d.getTime() / 86400000 - .4 + (144 + coordinates[0]) / 360))).map(d => d % 1).map(d => d >= .5 || d <= 0.05 ? NaN : d)
```

```{ojs}
localSets = sets.map(d => ((d.getTime() / 86400000 - .4 + (144 + coordinates[0]) / 360))).map(d => d % 1).map(d => d <= .5 || d >= .95 ? NaN : d)
```

```{ojs}
zonals = zonalNoons.map((d, i) => ({date: i, rise: zonalRises[i], noon: d, set: zonalSets[i]}))
```

```{ojs}
locals = localNoons.map((d, i) => ({date: i, rise: localRises[i], noon: d, set: localSets[i]}))
```

```{ojs}
times = [
  ["zonal", locals],
  ["local", zonals],
].flatMap(([symbol, values]) => values.map(d => ({symbol, ...d})))
```

```{ojs}
graticule = d3.geoGraticule().stepMinor([36,36]).stepMajor([36,36])()
```

```{ojs}
graticule.coordinates = graticule.coordinates.map(
  i => i.map(j => j.map((k, index, arr) => i.length === 3 && index === 0 ? k - 18 : k))
)
```

```{ojs}
land = topojson.feature(world, world.objects.land)
```

```{ojs}
world = (await fetch("https://cdn.jsdelivr.net/npm/world-atlas@1/world/110m.json")).json()
```

```{ojs}
countries = topojson.feature(world, world.objects.countries)
```

```{ojs}
topojson = require("topojson-client@3")
```

```{ojs}
colors = ({
  night: "#91afd6",
  day: "#ffe438",
  grid: "#4b6a79",
  ocean: "#adeeff",
  land: "#f5f1dc",
  sun: "#ffe438"
})
```

```{ojs}
label_style = `font: 13px/1.2 var(--sans-serif); width: 120px; font-size: ${label_size};`
```

```{ojs}
label_size = '80%'
```

```{ojs}
function input(config) {
  let {
    form,
    type = "text",
    attributes = {},
    action,
    getValue,
    title,
    description,
    format,
    display,
    submit,
    options
  } = config;
  const wrapper = html`<div></div>`;
  if (!form)
    form = html`<form>
	<input name=input type=${type} />
  </form>`;
  Object.keys(attributes).forEach(key => {
    const val = attributes[key];
    if (val != null) form.input.setAttribute(key, val);
  });
  if (submit)
    form.append(
      html`<input name=submit type=submit style="margin: 0 0.75em" value="${
        typeof submit == "string" ? submit : "Submit"
      }" />`
    );
  form.append(
    html`<output name=output style="font: 14px Menlo, Consolas, monospace; margin-left: 0.5em;"></output>`
  );
  if (title)
    form.prepend(
      html`<div style="font: 700 0.9rem sans-serif; margin-bottom: 3px;">${title}</div>`
    );
  if (description)
    form.append(
      html`<div style="font-size: 0.85rem; font-style: italic; margin-top: 3px;">${description}</div>`
    );
  if (format)
    format = typeof format === "function" ? format : d3format.format(format);
  if (action) {
    action(form);
  } else {
    const verb = submit
      ? "onsubmit"
      : type == "button"
      ? "onclick"
      : type == "checkbox" || type == "radio"
      ? "onchange"
      : "oninput";
    form[verb] = e => {
      e && e.preventDefault();
      const value = getValue ? getValue(form.input) : form.input.value;
      if (form.output) {
        const out = display ? display(value) : format ? format(value) : value;
        if (out instanceof window.Element) {
          while (form.output.hasChildNodes()) {
            form.output.removeChild(form.output.lastChild);
          }
          form.output.append(out);
        } else {
          form.output.value = out;
        }
      }
      form.value = value;
      if (verb !== "oninput")
        form.dispatchEvent(new CustomEvent("input", { bubbles: true }));
    };
    if (verb !== "oninput")
      wrapper.oninput = e => e && e.stopPropagation() && e.preventDefault();
    if (verb !== "onsubmit") form.onsubmit = e => e && e.preventDefault();
    form[verb]();
  }
  while (form.childNodes.length) {
    wrapper.appendChild(form.childNodes[0]);
  }
  form.append(wrapper);
  return form;
}
```

```{ojs}
d3format = require("d3-format@1")
```

```{ojs}
// https://talk.observablehq.com/t/legend-placement-options/8407/3
move = {
  d3.select(plot)
    .select("div")
    .raise() // Places swatch below the plot
    .style("float", "right"); // Floats the swatch on the right.
}
```

```{ojs}
// https://observablehq.com/@enjalot/draggable-world-map-coordinates-input
function worldMapCoordinates(config = {}, dimensions) {
  const {
    value = [], title, description, width = dimensions[0]
  } = Array.isArray(config) ? {value: config} : config;
  const height = dimensions[1];
  let [lon, lat] = value;
  lon = lon != null ? lon : null;
  lat = lat != null ? lat : null;
  const formEl = html`<form style="width: ${width}px;"></form>`;
  const context = DOM.context2d(width, height-width/11.5);
  const canvas = context.canvas;
  canvas.style.margin = `-6px 0 ${width > 400 ? -86 : -24}px`;
  const projection = d3
    .geoEquirectangular()
    .precision(0.1)
    .fitSize([width, height], { type: "Sphere" }).rotate([-153, 0]);
  const path = d3.geoPath(projection, context).pointRadius(2.5);
  formEl.append(canvas);

  function draw() {
    context.fillStyle = "#fff";
    context.fillRect(0, 0, width, height);
    context.beginPath(); path({type: "Sphere"});
    context.fillStyle = colors.ocean; context.fill();
    context.beginPath();
    path(graticule);
    context.lineWidth = 0.95;
    context.strokeStyle = `#aaa`;
    context.stroke();
    context.beginPath();
    path(land);
    context.fillStyle = colors.land;
    context.fill();
    context.beginPath();
    path(countries);
    context.lineWidth = .95;
    context.strokeStyle = `#000`;
    context.stroke();
    context.fillStyle = `#000`;
    context.font = width < 760 ? "12px serif" : width < 990 ? "11.6px serif" : "18px serif";
    d3.range(-1.5, 342 + 1, 36).map(x =>  context.fillText(long2zone(x), ...projection([x, 84.5 - (width < 400) * 3.6])));
    d3.range(-1.5, 342 + 1, 36).map(x =>  context.fillText(long2zone(x), ...projection([x, -62])));
    context.beginPath(), path(night), context.fillStyle = "rgba(0,0,255,0.1)", context.fill();
    context.beginPath(); path.pointRadius(17); path({type: "Point", coordinates: sun}); context.strokeStyle = "#0008"; context.fillStyle = "#ff0a"; context.lineWidth = 1; context.stroke(); context.fill();
    if (lon != null && lat != null) {
      path.pointRadius(17); context.strokeStyle = "black";
      context.beginPath(); path({type: "Point", coordinates: [lon, lat]}); context.lineWidth = 1; context.stroke();
      context.lineWidth = 6; 
      path.pointRadius(14); context.strokeStyle = "red";
      context.beginPath(); path({type: "Point", coordinates: [lon, lat]}); context.stroke();
    }
  }

  let drag = d3.drag()
    .on("drag", (event) => {
      let coords = projection.invert([event.x, event.y]);
      lon = +coords[0].toFixed(2);
      lat = +coords[1].toFixed(2);
      draw();
      canvas.dispatchEvent(new CustomEvent("input", { bubbles: true }));
    })

  d3.select(canvas).call(drag)

  canvas.onclick = function(ev) {
    const { offsetX, offsetY } = ev;
    let coords = projection.invert([offsetX, offsetY]);
    lon = +coords[0].toFixed(2);
    lat = +coords[1].toFixed(2);
    draw();
    canvas.dispatchEvent(new CustomEvent("input", { bubbles: true }));
  };

  draw();
  const form = input({
    type: "worldMapCoordinates",
    title,
    description,
    display: v => (width > 400) ? html`<div style="width: ${width}px; white-space: nowrap; color: #444; text-align: center; font: 18px monospace; position: relative; top: 58px; margin-bottom: 48px;">
        <span style="color: #000;">Zone:</span> ${lon != null ? long2zone(lon) : ""}
        &nbsp; &nbsp; 
        <span style="color: #000;">Longitude:</span> ${lon != null ? (long2turn(lon)).toFixed(0) : ""}
        &nbsp; &nbsp; 
        <span style="color: #000;">Latitude:</span> ${lat != null ? ((lati2turn1(lat))).toFixed(0) : ""} 
      </div>` : '',
    getValue: () => [lon != null ? lon : null, lat != null ? lat : null],
    form: formEl
  });
  return form;
}
```

```{ojs}
html`<style>
  div.observablehq:has(> svg#barClock) {
    text-align: center;
    margin-top: -12px;
  }
  div.observablehq:has(> svg#clock) {
    text-align: center;
    margin-top: -46px;
  }
  body > div > div:nth-child(6) > form {
    margin-top: -60px;
  }
</style>`
```

```{ojs}
function dote({ year = 0, day = 0, month = 3, dotm = 1, week = 0, dotw = 3,
                hour = 0, minute = 0, second = 0, millisecond = 0,
                zone = 0, utc = -9, degree = -162 } = {}) {
  const cycle = Math.floor((year >= 0 ? year : year - 399) / 400),
    yote = year - cycle * 400;
  return (
    yote * 365 + cycle * 146097 + Math.floor(yote / 4) - Math.floor(yote / 100)
    + day + Math.floor((153 * (month > 2 ? month - 3 : month + 9) + 2) / 5) + dotm - 1
    + week * 7 + dotw - 3 + (hour + minute / 60 + second / 3600 + millisecond / 3600000)
    / 24 - (zone + Math.floor(utc / 2.4) + 4 + Math.floor((degree + 162) / 36)) / 10
  );
}
```

```{ojs}
function doty(args) {
    const days = dote(args),
      cycle = Math.floor((days >= 0 ? days : days - 146096) / 146097),
      dotc = days - cycle * 146097,
      yotc = Math.floor((dotc - Math.floor(dotc / 1460)
        + Math.floor(dotc / 36524) - Math.floor(dotc / 146096)) / 365);
    return [yotc + cycle * 400,
            dotc + Math.floor(yotc / 100) - yotc * 365 - Math.floor(yotc / 4)];
}
```

```{ojs}
function year(args) {
    const days = dote(args),
      cycle = Math.floor((days >= 0 ? days : days - 146096) / 146097),
      dotc = days - cycle * 146097;
    return (
        dotc - Math.floor(dotc / 1460) + Math.floor(dotc / 36524)
        - Math.floor(dotc / 146096)) / 365 + cycle * 400;
}
```

```{ojs}
function leap(year = 1970) {
    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
}
```

```{ojs}
function deco(args, {lead = "0", minus = false, emoji = false} = {}) {
  let zone = args.zone, utc = args.utc, degree = args.degree;
  args.zone = 0; args.utc = -9; args.degree = -162;
  zone = zone ?? 0 + Math.floor((utc ?? -9) / 2.4) + 4 + Math.floor(
    ((degree ?? -162) + 162) / 36);
  let [year, days] = doty(args);
  return `${emoji ? "ðŸ—“ï¸" : ""}${
  (year + minus).toString().padStart(4, lead)}${minus ? "-" : "+"}${
  Math.abs(Math.floor(days = days - (365 + leap(year + 1)) * minus)
  ).toString().padStart(3, lead)}${emoji ? "ðŸ•°ï¸" : ""}ï¸${
  Math.abs(days % 1 * 10).toFixed(4)}${zone ? (minus ? "+" : "-") + String(zone) : ""}`
}
```

```{ojs}
currentDeco = deco({day: 719468, millisecond: unix, zone: long2zone(coordinates[0])})
```

```{ojs}
currentDoty = currentDeco.slice(5)
```

```{ojs}
dotyDate = currentDoty.slice(0, 3)
```

```{ojs}
dotyDek = currentDoty.slice(0, 2)
```

```{ojs}
dotyDotd = currentDoty[2]
```

```{ojs}
barTime = (unix2dote(unix, long2zone(coordinates[0]))[0]).toString().split(".")[1].slice(0, 8)
```

```{ojs}
barCents = barTime.slice(0, 2)
```

```{ojs}
barDD = barTime[0]
```

```{ojs}
barMils = barTime.slice(1, 3)
```

```{ojs}
barBeats = barTime.slice(3, 5)
```

```{ojs}
barMb = barTime.slice(5)
```

```{ojs}
html`<style>
  .tickLabel, .tickLabel1, .tickLabel2, .timeLabel {
    fill: #000;
    font-family: sans-serif;
    font-size: 20px;
    text-anchor: middle;
  }
  .timeLabel {
    text-anchor: start;
  }
  .timeBar, .timeBarFull {
    x: 1px;
    height: 25px;
    rx: 5px;
    stroke: #aaa;
  }
  .timeBar {
    fill: #e8e8e8;
  }
  .timeBarFull {
    fill: #ccffff;
  }
  .background {
    fill: white;
  }
  .tickDek, .tickDotd, .tickDotd1, .tickC, .tickC1, .tickM, .tickM1, .tickB, .tickB1 {
    stroke: none;
    fill: #666;
    width: 1px;
  }
</style>`
```

