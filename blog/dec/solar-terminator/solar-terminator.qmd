---
title: 'Solar Terminator with Dec graticules'
author: 'Martin Laptev'
format: html
echo: false
observable: 'https://observablehq.com/@dec/solar-terminator'
---

```{ojs}
md`# Solar Terminator with Dec graticules

The [solar terminator](https://en.wikipedia.org/wiki/Terminator_%28solar%29#:~:text=a%20moving%20line%20that%20divides%20the%20daylit%20side%20and%20the%20dark%20night%20side%20of%20a%20planetary%20body) maps below show where is currently night (blue) and day (unshaded). The vertical lines on the maps are [Dec graticules](/@dec/irc) which separate the 10 [Dec time zones](/@dec/loc) numbered 0 to 9 on the maps. Dec is a [measurement system](https://en.wikipedia.org/wiki/System_of_units_of_measurement#:~:text=a%20collection%20of%20units%20of%20measurement%20and%20rules%20relating%20them%20to%20each%20other) that [I](https://maptv.github.io) created to measureâ³time,ðŸ“position,ðŸ§­orientation,ðŸ“angles, andðŸ”„cycles in [turns](https://en.wikipedia.org/wiki/Turn_%28angle%29#:~:text=a%20unit%20of%20plane%20angle%20measurement%20equal%20to%202%CF%80%C2%A0radians%2C%20360%C2%A0degrees) ([${tex`\tau`}](https://en.wikipedia.org/wiki/Turn_%28angle%29#:~:text=the%20Greek%20letter,to%20one%20turn)) instead of months, weeks, hours, minutes, seconds, and degrees. For time measurement, Dec uses days and years, which are turns of a [celestial body](https://en.wikipedia.org/wiki/Astronomical_object#:~:text=a%20single%2C%20tightly%20bound%2C%20contiguous%20entity) on [its axis](https://en.wikipedia.org/wiki/Axial_tilt#:~:text=the%20imaginary%20line%20that%20passes%20through%20both%20the%20north%20pole%20and%20south%20pole) and around [the point it orbits](https://en.wikipedia.org/wiki/Barycenter_%28astronomy%29#:~:text=the%20point%20about%20which%20the%20bodies%20orbit), respectively.`
```

```{ojs}
viewof choice = Inputs.select(
  projections, {label: "Projection:", format: x => x.name, value: projections.find(t => t.name === "Miller")})
```

```{ojs}
map = {
  const context = DOM.context2d(width, height);
  const path = d3.geoPath(projection, context);
  context.beginPath(), path(graticule), context.strokeStyle = "#00000099", context.stroke();
  context.beginPath(), path(land), context.fillStyle = "#333f", context.fill();
  context.beginPath(), path(night), context.fillStyle = "rgba(0,0,255,0.3)", context.fill();
  context.beginPath(), path(sphere), context.strokeStyle = "#000", context.stroke();
  context.beginPath(), path(borders), context.strokeStyle = "#fff", context.stroke();
  context.beginPath(); path.pointRadius(17); path({type: "Point", coordinates: [sun[0]+360, sun[1]]}); context.strokeStyle = "#00000088"; context.fillStyle = "#ffff00aa"; context.lineWidth = 1; context.stroke(); context.fill();
  context.font = "bold 24px serif";
  context.fillStyle = "#000";
  d3.range(-2, 342 + 1, 36).map((x, i) => context.fillText(i, projection([x, 90])[0] - (width < 400) * 4, 40 - (width < 400) * 20));
  context.fillStyle = "#fff";
  d3.range(-2, 342 + 1, 36).map((x, i) => context.fillText(i, projection([x, 90])[0] - (width < 400) * 4, 825 - (width < 400) * 281 - (width < 800) * 120));
  return context.canvas;
}
```

```{ojs}
viewof coordinates = worldMapCoordinates([162, 0], [width, Math.round((210 / 400) * width)])
```

```{ojs}
md`The maps above show how [Meridian 0](https://en.wikipedia.org/wiki/126th_meridian_west#:~:text=a%20line%20of%20longitude%20that%20extends%20from%20the%20North%20Pole%20across%20the%20Arctic%20Ocean%2C%20North%20America%2C%20the%20Pacific%20Ocean%2C%20the%20Southern%20Ocean%2C%20and%20Antarctica%20to%20the%20South%20Pole), the Dec [International Date Line](https://en.wikipedia.org/wiki/International_Date_Line#:~:text=the%20line%20between%20the%20South%20and%20North%20Poles%20that%20is%20the%20boundary%20between%20one%20calendar%20day%20and%20the%20next) and [prime meridian](https://en.wikipedia.org/wiki/Prime_meridian#:~:text=an%20arbitrarily%2Dchosen%20meridian%20%28a%20line%20of%20longitude%29%20in%20a%20geographic%20coordinate%20system%20at%20which%20longitude%20is%20defined%20to%20be%200%C2%B0), cuts across the Atlantic Ocean just West of Africa and marks the start of Zone 0, the leftmost Dec time zone on the map. Dec has 10 time zones which are each 1 deciturn (10% of a turn) wide and are numbered 0 through 9, like the [meridians](https://en.wikipedia.org/wiki/Meridian_%28geography%29#:~:text=words%2C%20it%20is-,a%20line%20of%20longitude,-.%20The%20position%20of) that separate them. For more Dec maps, check out these notebooks:
- [Declock](/@dec/loc)
- [Decalc](/@dec/alc)
- [Decalendar](/@dec/al)
- [Decaliper](/@dec/ali)
- [Decirc](/@dec/irc)
- [The Sun's view of the Earth](/@dec/the-suns-view-of-the-earth)`
```

```{ojs}
function lati2turn1(degrees = -180, e = 3) {
  // turns: e=0, deciturns: e=1, etc.
  return (degrees %= 360) / (360 / 10**e) % 10**e;
}
```

```{ojs}
// https://observablehq.com/@enjalot/draggable-world-map-coordinates-input
function worldMapCoordinates(config = {}, dimensions) {
  const {
    value = [], title, description, width = dimensions[0]
  } = Array.isArray(config) ? {value: config} : config;
  const height = dimensions[1];
  let [lon, lat] = value;
  lon = lon != null ? lon : null;
  lat = lat != null ? lat : null;
  const formEl = html`<form style="width: ${width}px;"></form>`;
  const context = DOM.context2d(width, height-width/11.5);
  const canvas = context.canvas;
  canvas.style.margin = `-6px 0 ${width > 400 ? -12 : -18}px`;
  const projection = d3
    .geoEquirectangular()
    .precision(0.1)
    .fitSize([width, height], { type: "Sphere" }).rotate([-153, 0]);
  const path = d3.geoPath(projection, context).pointRadius(2.5);
  formEl.append(canvas);

  function draw() {
    context.fillStyle = "#fff";
    context.fillRect(0, 0, width, height);
    context.beginPath(); path({type: "Sphere"});
    context.fillStyle = colors.ocean; context.fill();
    context.beginPath();
    path(graticule);
    context.lineWidth = 0.95;
    context.strokeStyle = `#aaa`;
    context.stroke();
    context.beginPath();
    path(land);
    context.fillStyle = colors.land;
    context.fill();
    context.beginPath();
    path(borders);
    context.lineWidth = .95;
    context.strokeStyle = `#000`;
    context.stroke();
    context.fillStyle = `#000`;
    context.font = width < 760 ? "12px serif" : "18px serif";
    d3.range(-1.5, 342 + 1, 36).map(x =>  context.fillText(long2zone(x), ...projection([x, 83.5 - (width < 400) * 3.6])));
    d3.range(-1.5, 342 + 1, 36).map(x =>  context.fillText(long2zone(x), ...projection([x, -62])));
    context.beginPath(), path(night), context.fillStyle = "rgba(0,0,255,0.1)", context.fill();
    context.beginPath(); path.pointRadius(17); path({type: "Point", coordinates: sun}); context.strokeStyle = "#0008"; context.fillStyle = "#ff0a"; context.lineWidth = 1; context.stroke(); context.fill();
  }

  let drag = d3.drag()
    .on("drag", (event) => {
      let coords = projection.invert([event.x, event.y]);
      lon = +coords[0].toFixed(2);
      lat = +coords[1].toFixed(2);
      draw();
      canvas.dispatchEvent(new CustomEvent("input", { bubbles: true }));
    })

  d3.select(canvas).call(drag)

  canvas.onclick = function(ev) {
    const { offsetX, offsetY } = ev;
    let coords = projection.invert([offsetX, offsetY]);
    lon = +coords[0].toFixed(2);
    lat = +coords[1].toFixed(2);
    draw();
    canvas.dispatchEvent(new CustomEvent("input", { bubbles: true }));
  };

  draw();
  const form = input({
    type: "worldMapCoordinates",
    title,
    description,
    display: v => (width > 400) ? html`<div style="width: ${width}px; white-space: nowrap; color: #444; text-align: center; font: 18px monospace; position: absolute; top: -15px;">
        <span style="color: #000;">Zone:</span> ${lon != null ? long2zone(lon) : ""}
        &nbsp; &nbsp; 
        <span style="color: #000;">Longitude:</span> ${lon != null ? (long2turn(lon)).toFixed(0) : ""}
        &nbsp; &nbsp; 
        <span style="color: #000;">Latitude:</span> ${lat != null ? ((lati2turn1(lat))).toFixed(0) : ""} 
      </div>` : '',
    getValue: () => [lon != null ? lon : null, lat != null ? lat : null],
    form: formEl
  });
  return form;
}
```

```{ojs}
projections = [
   {name: "CylindricalEqualArea", value: d3.geoCylindricalEqualArea},
   {name: "CylindricalStereographic", value: d3.geoCylindricalStereographic},
   {name: "Eckert1", value: d3.geoEckert1},
   {name: "Eckert2", value: d3.geoEckert2},
   {name: "Eckert3", value: d3.geoEckert3},
   {name: "Eckert4", value: d3.geoEckert4},
   {name: "Eckert5", value: d3.geoEckert5},
   {name: "Eckert6", value: d3.geoEckert6},
   {name: "Equirectangular", value: d3.geoEquirectangular},
   {name: "Hufnagel", value: d3.geoHufnagel},
   {name: "Kavrayskiy7", value: d3.geoKavrayskiy7},
   {name: "Miller", value: d3.geoMiller},
   {name: "MtFlatPolarParabolic", value: d3.geoMtFlatPolarParabolic},
   {name: "MtFlatPolarQuartic", value: d3.geoMtFlatPolarQuartic},
   {name: "MtFlatPolarSinusodial", value: d3.geoMtFlatPolarSinusoidal},
   {name: "NaturalEarth1", value: d3.geoNaturalEarth1},
   {name: "NaturalEarth2", value: d3.geoNaturalEarth2},
   {name: "NellHammer", value: d3.geoNellHammer},
   {name: "Patterson", value: d3.geoPatterson},
   {name: "Robinson", value: d3.geoRobinson},
   {name: "Times", value: d3.geoTimes},
   {name: "Wagner4", value: d3.geoWagner4},
   {name: "Wagner6", value: d3.geoWagner6},
   {name: "Winkel3", value: d3.geoWinkel3},
]
```

```{ojs}
d3 = require("d3@5", "d3-drag@3", "d3-array@2", "d3-geo@2", "d3-geo-projection@3")
```

```{ojs}
colors = ({
  night: "#719fb6",
  day: "#ffe438",
  grid: "#4b6a79",
  ocean: "#adeeff",
  land: "#f5f1dc",
  sun: "#ffe438"
})
```

```{ojs}
function input(config) {
  let {
    form,
    type = "text",
    attributes = {},
    action,
    getValue,
    title,
    description,
    format,
    display,
    submit,
    options
  } = config;
  const wrapper = html`<div></div>`;
  if (!form)
    form = html`<form>
	<input name=input type=${type} />
  </form>`;
  Object.keys(attributes).forEach(key => {
    const val = attributes[key];
    if (val != null) form.input.setAttribute(key, val);
  });
  if (submit)
    form.append(
      html`<input name=submit type=submit style="margin: 0 0.75em" value="${
        typeof submit == "string" ? submit : "Submit"
      }" />`
    );
  form.append(
    html`<output name=output style="font: 14px Menlo, Consolas, monospace; margin-left: 0.5em;"></output>`
  );
  if (title)
    form.prepend(
      html`<div style="font: 700 0.9rem sans-serif; margin-bottom: 3px;">${title}</div>`
    );
  if (description)
    form.append(
      html`<div style="font-size: 0.85rem; font-style: italic; margin-top: 3px;">${description}</div>`
    );
  if (format)
    format = typeof format === "function" ? format : d3format.format(format);
  if (action) {
    action(form);
  } else {
    const verb = submit
      ? "onsubmit"
      : type == "button"
      ? "onclick"
      : type == "checkbox" || type == "radio"
      ? "onchange"
      : "oninput";
    form[verb] = e => {
      e && e.preventDefault();
      const value = getValue ? getValue(form.input) : form.input.value;
      if (form.output) {
        const out = display ? display(value) : format ? format(value) : value;
        if (out instanceof window.Element) {
          while (form.output.hasChildNodes()) {
            form.output.removeChild(form.output.lastChild);
          }
          form.output.append(out);
        } else {
          form.output.value = out;
        }
      }
      form.value = value;
      if (verb !== "oninput")
        form.dispatchEvent(new CustomEvent("input", { bubbles: true }));
    };
    if (verb !== "oninput")
      wrapper.oninput = e => e && e.stopPropagation() && e.preventDefault();
    if (verb !== "onsubmit") form.onsubmit = e => e && e.preventDefault();
    form[verb]();
  }
  while (form.childNodes.length) {
    wrapper.appendChild(form.childNodes[0]);
  }
  form.append(wrapper);
  return form;
}
```

```{ojs}
html`<style>
  body > div > div:nth-child(4) > form > div > output > div {display: none;}
</style>`
```

```{ojs}
d3format = require("d3-format@1")
```

```{ojs}
label_style = `font: 13px/1.2 var(--sans-serif); width: 120px; font-size: ${label_size};`
```

```{ojs}
label_size = '80%'
```

```{ojs}
function long2turn(degrees = -180, e = 3) {
  // turns: e=0, deciturns: e=1, etc.
  return (((degrees %= 360) < 0 ? degrees + 360 : degrees) + 18) / (360 / 10**e) % 10**e;
}
```

```{ojs}
function long2zone(degrees = -180) {
  return Math.floor(long2turn(degrees, 1));
}
```

```{ojs}
height = {
  const [[x0, y0], [x1, y1]] = d3.geoPath(projection.fitWidth(width, sphere)).bounds(sphere);
  const dy = Math.ceil(y1 - y0), l = Math.min(Math.ceil(x1 - x0), dy);
  projection.scale(projection.scale() * (l - 1) / l).precision(0.2);
  return dy;
}
```

```{ojs}
projection = choice.value().rotate([-153, 0])
```

```{ojs}
sun = {
  const now = new Date;
  const day = new Date(+now).setUTCHours(0, 0, 0, 0);
  const t = solar.century(now);
  const longitude = (day - now) / 864e5 * 360 - 180;
  return [longitude - solar.equationOfTime(t) / 4, solar.declination(t)];
}
```

```{ojs}
night = d3.geoCircle()
    .radius(90)
    .center(antipode(sun))
  ()
```

```{ojs}
antipode = ([longitude, latitude]) => [longitude + 180, -latitude]
```

```{ojs}
sphere = ({type: "Sphere"})
```

```{ojs}
graticule = d3.geoGraticule().stepMinor([36,36]).stepMajor([36,36])()
```

```{ojs}
graticule.coordinates = graticule.coordinates.map(
  i => i.map(j => j.map((k, index, arr) => i.length === 3 && index === 0 ? k - 18 : k))
)
```

```{ojs}
land = topojson.feature(world, world.objects.land)
```

```{ojs}
world = fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/land-50m.json").then(response => response.json())
```

```{ojs}
topojson = require("topojson-client@3")
```

```{ojs}
solar = require("solar-calculator@0.3/dist/solar-calculator.min.js")
```

```{ojs}
d3require = require("d3@5", "d3-drag@3", "d3-array@2", "d3-geo@2", "d3-geo-projection@3")
```

```{ojs}
borders = topojson.mesh(countries, countries.objects.countries, (a, b) => a !== b)
```

```{ojs}
countries = fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-50m.json").then(response => response.json())
```

